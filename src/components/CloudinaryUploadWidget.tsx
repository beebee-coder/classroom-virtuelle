// src/components/CloudinaryUploadWidget.tsx
'use client';

import { useState, useEffect, createContext, useCallback, useRef } from 'react';

interface CloudinaryScriptContextType {
  loaded: boolean;
}

interface CloudinaryUploadWidgetProps {
  onUpload: (result: any) => void;
  children: (props: { open: () => void; loaded: boolean; error: string | null }) => React.ReactNode;
}

interface CloudinaryWindow extends Window {
  cloudinary?: {
    createUploadWidget: (options: any, callback: (error: any, result: any) => void) => any;
  };
}

// Types pour les r√©sultats Cloudinary
interface CloudinaryUploadResult {
  event: string;
  info?: {
    public_id: string;
    secure_url: string;
    original_filename: string;
    format: string;
    bytes: number;
    width?: number;
    height?: number;
  };
}

const CloudinaryScriptContext = createContext<CloudinaryScriptContextType>({ loaded: false });

function CloudinaryUploadWidget({ onUpload, children }: CloudinaryUploadWidgetProps) {
  const [loaded, setLoaded] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const widgetRef = useRef<any>(null);

  // R√©cup√©ration des variables d'environnement avec valeurs par d√©faut
  const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME || 'demo';
  const uploadPreset = process.env.NEXT_PUBLIC_CLOUDINARY_UPLOAD_PRESET || 'ml_default';

  useEffect(() => {
    console.log('üñºÔ∏è [WIDGET] Initialisation du widget Cloudinary...');
    console.log(`üîß [WIDGET] Configuration - Cloud: ${cloudName}, Preset: ${uploadPreset}`);

    // V√©rification des variables critiques
    if (!cloudName || cloudName === 'demo') {
      console.warn('‚ö†Ô∏è [WIDGET] CloudName manquant ou en mode d√©mo - certaines fonctionnalit√©s peuvent √™tre limit√©es');
    }

    const cloudinaryWindow = window as CloudinaryWindow;

    // V√©rifier si le script est d√©j√† charg√©
    if (cloudinaryWindow.cloudinary) {
      console.log('‚úÖ [WIDGET] Script Cloudinary d√©j√† charg√©.');
      setLoaded(true);
      initializeWidget();
      return;
    }

    // V√©rifier si le script est en cours de chargement
    if (document.getElementById('cloudinary-upload-widget')) {
      console.log('‚è≥ [WIDGET] Script Cloudinary d√©j√† en cours de chargement.');
      return;
    }

    const script = document.createElement('script');
    script.setAttribute('async', '');
    script.setAttribute('id', 'cloudinary-upload-widget');
    script.src = 'https://upload-widget.cloudinary.com/global/all.js';
    
    const handleLoad = () => {
      console.log('‚úÖ [WIDGET] Script Cloudinary charg√© avec succ√®s.');
      setLoaded(true);
      setError(null);
      initializeWidget();
    };

    const handleError = (err: ErrorEvent) => {
      console.error('‚ùå [WIDGET] √âchec du chargement du script Cloudinary:', err);
      setError('Erreur de chargement du script Cloudinary. V√©rifiez votre connexion.');
    };

    script.addEventListener('load', handleLoad);
    script.addEventListener('error', handleError);
    document.body.appendChild(script);

    return () => {
      script.removeEventListener('load', handleLoad);
      script.removeEventListener('error', handleError);
      if (document.body.contains(script)) {
        document.body.removeChild(script);
      }
      // Nettoyer le widget
      if (widgetRef.current) {
        try {
          widgetRef.current.destroy();
          widgetRef.current = null;
        } catch (e) {
          console.warn('‚ö†Ô∏è [WIDGET] Erreur lors du nettoyage du widget:', e);
        }
      }
    };
  }, [cloudName, uploadPreset]);

  const initializeWidget = useCallback(() => {
    const cloudinaryWindow = window as CloudinaryWindow;
    
    if (!cloudinaryWindow.cloudinary) {
      console.error('‚ùå [WIDGET] Cloudinary non disponible apr√®s chargement');
      setError('Cloudinary non disponible');
      return;
    }

    try {
      const options = {
        cloudName: cloudName,
        uploadPreset: uploadPreset,
        folder: "classroom_connector_proofs",
        cropping: false, // D√©sactiv√© pour √©viter les erreurs avec les presets non sign√©s
        sources: ['local', 'url', 'camera'],
        multiple: false,
        maxFiles: 1,
        clientAllowedFormats: ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'webp'],
        maxFileSize: 5000000, // 5MB
        styles: {
          palette: {
            window: "#FFFFFF",
            windowBorder: "#90A0B3",
            tabIcon: "#0078FF",
            menuIcons: "#5A616A",
            textDark: "#000000",
            textLight: "#FFFFFF",
            link: "#0078FF",
            action: "#FF620C",
            inactiveTabIcon: "#0E2F5A",
            error: "#F44235",
            inProgress: "#0078FF",
            complete: "#20B832",
            sourceBg: "#E4EBF1"
          },
          fonts: {
            default: null,
            "'Poppins', sans-serif": {
              url: "https://fonts.googleapis.com/css?family=Poppins",
              active: true
            }
          }
        }
      };

      const handleUploadCallback = (error: any, result: CloudinaryUploadResult) => {
        if (error) {
          console.error('‚ùå [WIDGET] Erreur d\'upload Cloudinary:', error);
          
          // Gestion sp√©cifique des erreurs Cloudinary
          if (error.status === 'upload preset must be whitelisted for unsigned uploads') {
            setError('Configuration Cloudinary incorrecte. Contactez l\'administrateur.');
          } else {
            setError(`Erreur d'upload: ${error.status || 'Erreur inconnue'}`);
          }
          return;
        }

        if (!result) return;

        switch (result.event) {
          case 'success':
            console.log('‚úÖ [WIDGET] Upload r√©ussi:', result.info);
            setError(null);
            onUpload(result);
            break;
            
          case 'close':
            console.log('üö™ [WIDGET] Widget ferm√©.');
            setError(null);
            break;
            
          case 'abort':
            console.log('‚èπÔ∏è [WIDGET] Upload annul√©.');
            setError(null);
            break;
            
          case 'display-changed':
            // √âv√©nement normal de changement d'affichage, pas d'erreur
            break;
            
          default:
            console.log(`üì¶ [WIDGET] √âv√©nement ${result.event} re√ßu`);
        }
      };

      widgetRef.current = cloudinaryWindow.cloudinary.createUploadWidget(
        options,
        handleUploadCallback
      );

      console.log('‚úÖ [WIDGET] Widget Cloudinary initialis√© avec succ√®s');

    } catch (err) {
      console.error('‚ùå [WIDGET] Erreur lors de l\'initialisation du widget:', err);
      setError('Erreur d\'initialisation du widget Cloudinary');
    }
  }, [cloudName, uploadPreset, onUpload]);

  const openWidget = useCallback(() => {
    console.log('üöÄ [WIDGET] Tentative d\'ouverture du widget...');
    
    if (!loaded) {
      console.error("‚ùå [WIDGET] Script Cloudinary pas encore charg√©.");
      setError('Veuillez patienter, le widget est en cours de chargement...');
      return;
    }

    if (!widgetRef.current) {
      console.error("‚ùå [WIDGET] Widget non initialis√©.");
      setError('Widget non initialis√©. Veuillez r√©essayer.');
      return;
    }

    try {
      widgetRef.current.open();
      console.log('‚úÖ [WIDGET] Widget ouvert avec succ√®s');
      setError(null);
    } catch (err) {
      console.error('‚ùå [WIDGET] Erreur √† l\'ouverture du widget:', err);
      setError('Impossible d\'ouvrir le widget. V√©rifiez votre connexion.');
    }
  }, [loaded]);

  return (
    <CloudinaryScriptContext.Provider value={{ loaded }}>
      {children({ open: openWidget, loaded, error })}
    </CloudinaryScriptContext.Provider>
  );
}

export { CloudinaryUploadWidget, CloudinaryScriptContext };
export type { CloudinaryUploadResult, CloudinaryUploadWidgetProps };