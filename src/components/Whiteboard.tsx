// src/components/Whiteboard.tsx
'use client';
import { Tldraw, useEditor, Editor, getSnapshot, TLStoreSnapshot } from '@tldraw/tldraw';
import '@tldraw/tldraw/tldraw.css';
import { useEffect } from 'react';

interface WhiteboardProps {
  sessionId: string;
  initialSnapshot?: TLStoreSnapshot;
  isController: boolean; // Nouveau: pour savoir si l'utilisateur actuel a le contr√¥le
  onPersist?: (snapshot: TLStoreSnapshot) => void;
}

// Composant interne pour g√©rer la logique de l'√©diteur
function EditorManager({ onPersist, initialSnapshot, isController }: Omit<WhiteboardProps, 'sessionId'>) {
    const editor = useEditor();

    useEffect(() => {
        // Appliquer le snapshot initial ou les mises √† jour re√ßues
        if (initialSnapshot) {
            try {
                // Ne charger que si le snapshot est diff√©rent pour √©viter les re-renders
                const currentSnapshot = getSnapshot(editor.store);
                if (JSON.stringify(currentSnapshot) !== JSON.stringify(initialSnapshot)) {
                   editor.store.loadSnapshot(initialSnapshot);
                }
            } catch (e) {
                console.error("Erreur lors du chargement du snapshot du tableau blanc:", e);
            }
        }
    }, [editor, initialSnapshot]);
    
    useEffect(() => {
        // Mettre √† jour le mode lecture/√©criture en fonction du contr√¥le
        editor.updateInstanceState({ isReadonly: !isController });

        // Si l'utilisateur est le contr√¥leur, on active la persistance
        if (isController && onPersist) {
             let lastPersistedState: string | null = null;
            
            const handleChange = () => {
                const snapshot = getSnapshot(editor.store);
                const jsonSnapshot = JSON.stringify(snapshot);

                if (lastPersistedState !== jsonSnapshot) {
                    console.log(`üé® [Whiteboard] - L'utilisateur contr√¥leur a fait une mise √† jour, envoi des donn√©es...`);
                    onPersist(snapshot);
                    lastPersistedState = jsonSnapshot;
                }
            };
            
            const debouncedHandleChange = debounce(handleChange, 300);
            const unsubscribe = editor.store.listen(debouncedHandleChange);

            // Fonction de nettoyage
            return () => unsubscribe();
        }

    }, [editor, onPersist, isController]);


    return null;
}


export function Whiteboard({ sessionId, onPersist, initialSnapshot, isController }: WhiteboardProps) {
  return (
    <div className="h-full w-full">
      <Tldraw 
        key={`${sessionId}-${isController}`} // Change la cl√© pour forcer le re-render si le contr√¥le change
        persistenceKey={`whiteboard-${sessionId}`}
      >
        <EditorManager 
          onPersist={onPersist}
          initialSnapshot={initialSnapshot}
          isController={isController}
        />
      </Tldraw>
    </div>
  );
}

function debounce<T extends (...args: any[]) => void>(func: T, wait: number): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null;
  return function(...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func(...args);
    };
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };
}
