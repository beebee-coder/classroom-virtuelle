// src/components/SessionClient.tsx
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import type { Instance as PeerInstance, SignalData as PeerSignalData } from 'simple-peer';
import * as SimplePeer from 'simple-peer';

import { pusherClient } from '@/lib/pusher/client';
import { useToast } from '@/hooks/use-toast';
import { User, Role, SessionParticipant, ClassroomWithDetails } from '@/lib/types';
import SessionLoading from './SessionLoading';
import { TeacherSessionView } from './session/TeacherSessionView';
import { StudentSessionView } from './session/StudentSessionView';
import { SessionHeader } from './session/SessionHeader';
import { PermissionPrompt } from './PermissionPrompt';
import { endCoursSession, broadcastTimerEvent, broadcastActiveTool } from '@/lib/actions';
import { ComprehensionLevel } from './StudentSessionControls';
import { SessionClientProps, PeerData, SignalPayload, PusherSubscriptionSucceededEvent, PusherMemberEvent, IncomingSignalData, SpotlightEvent, HandRaiseEvent, UnderstandingEvent, TimerEvent, ToolEvent, DocumentEvent, RemoteParticipant } from '@/types';
import { TLStoreSnapshot } from '@tldraw/tldraw';

const INITIAL_TIMER_DURATION = 3600; // 1 heure en secondes

export default function SessionClient({
  sessionId,
  initialStudents,
  initialTeacher,
  currentUserRole,
  currentUserId,
  classroom,
}: SessionClientProps) {
  const router = useRouter();
  const { toast } = useToast();
  
  // √âtats principaux
  const [loading, setLoading] = useState<boolean>(true);
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [screenStream, setScreenStream] = useState<MediaStream | null>(null);
  const [peers, setPeers] = useState<PeerData[]>([]);
  const [onlineUserIds, setOnlineUserIds] = useState<string[]>([]);
  const [spotlightedParticipantId, setSpotlightedParticipantId] = useState<string | null>(initialTeacher?.id || null);
  
  // √âtats d'interaction
  const [raisedHands, setRaisedHands] = useState<Set<string>>(new Set());
  const [understandingStatus, setUnderstandingStatus] = useState<Map<string, ComprehensionLevel>>(new Map());
  const [isEndingSession, setIsEndingSession] = useState<boolean>(false);
  const [activeTool, setActiveTool] = useState<string>('whiteboard');
  const [documentUrl, setDocumentUrl] = useState<string | null>(null);
  const [whiteboardSnapshot, setWhiteboardSnapshot] = useState<TLStoreSnapshot | null>(null);

  // √âtats pour le minuteur
  const [timerDuration, setTimerDuration] = useState<number>(INITIAL_TIMER_DURATION);
  const [timerTimeLeft, setTimerTimeLeft] = useState<number>(timerDuration);
  const [isTimerRunning, setIsTimerRunning] = useState<boolean>(false);
  const timerIntervalRef = useRef<NodeJS.Timeout | null>(null);
  
  const allSessionUsers: SessionParticipant[] = [initialTeacher, ...initialStudents];
  const peersRef = useRef<PeerData[]>([]);
  const screenPeerRef = useRef<PeerInstance | null>(null);
  const channelRef = useRef<any>(null);
  const isProcessingSignalRef = useRef<Set<string>>(new Set());
  const pendingSignalsRef = useRef<Map<string, PeerSignalData[]>>(new Map());

  // ---=== 1. GESTION DES FLUX M√âDIAS ===---
  useEffect(() => {
    const getMedia = async (): Promise<void> => {
      try {
        const stream: MediaStream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 1280, height: 720 },
          audio: true 
        });
        setLocalStream(stream);
        console.log('‚úÖ [MEDIA] - Flux local (cam√©ra/micro) obtenu.');
      } catch (error) {
        console.error('‚ùå [MEDIA] - Erreur d\'acc√®s √† la cam√©ra/micro:', error);
        toast({
          variant: 'destructive',
          title: 'Erreur M√©dia',
          description: 'Impossible d\'acc√©der √† votre cam√©ra et/ou microphone.'
        });
        // Continuer m√™me sans m√©dia
        setLoading(false);
      } finally {
        setLoading(false);
      }
    };
    getMedia();

    return (): void => {
      localStream?.getTracks().forEach(track => {
        track.stop();
      });
      screenStream?.getTracks().forEach(track => {
        track.stop();
      });
    };
  }, []);

  const toggleScreenShare = async (): Promise<void> => {
    if (screenStream) {
      screenStream.getTracks().forEach(track => track.stop());
      setScreenStream(null);
      if (screenPeerRef.current) {
        screenPeerRef.current.destroy();
        screenPeerRef.current = null;
      }
      toast({ title: 'Partage d\'√©cran arr√™t√©' });
    } else {
      try {
        const stream: MediaStream = await navigator.mediaDevices.getDisplayMedia({ 
          video: true,
          audio: true 
        });
        
        // G√©rer l'arr√™t manuel du partage d'√©cran
        stream.getTracks().forEach(track => {
          track.onended = () => {
            setScreenStream(null);
            if (screenPeerRef.current) {
              screenPeerRef.current.destroy();
              screenPeerRef.current = null;
            }
            toast({ title: 'Partage d\'√©cran arr√™t√©' });
          };
        });
        
        setScreenStream(stream);
        toast({ title: 'Partage d\'√©cran activ√©' });
      } catch (error) {
        console.log('Partage d\'√©cran annul√© par l\'utilisateur');
      }
    }
  };

  const signalViaAPI = async (payload: SignalPayload): Promise<void> => {
    try {
      await fetch('/api/pusher/signal', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
      });
    } catch (error) {
      console.error('‚ùå [SIGNAL] - Erreur d\'envoi du signal:', error);
    }
  }

  // ---=== 2. GESTION DES CONNEXIONS PEER-TO-PEER CORRIG√âE ===---
  const createPeer = (targetUserId: string, initiator: boolean, stream: MediaStream): PeerInstance => {
    console.log(`ü§ù [PEER] - Cr√©ation d'un peer pour ${targetUserId}. Initiateur: ${initiator}`);
    
    const peer: PeerInstance = new SimplePeer.default({
      initiator,
      trickle: false,
      stream: stream || undefined,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:global.stun.twilio.com:3478' }
        ]
      }
    });

    peer.on('signal', (signal: PeerSignalData) => {
      console.log(`üì§ [PEER] - Envoi du signal de ${currentUserId} vers ${targetUserId}`);
      signalViaAPI({
        channelName: `presence-session-${sessionId}`,
        userId: currentUserId,
        target: targetUserId,
        signal,
        isReturnSignal: !initiator,
      });
    });

    peer.on('connect', () => {
      console.log(`üîó [PEER] - Connexion √©tablie avec ${targetUserId}`);
      // Mettre √† jour l'√©tat de connexion
      setPeers(prev => prev.map(p => 
        p.id === targetUserId ? { ...p, isConnected: true } : p
      ));
      peersRef.current = peersRef.current.map(p => 
        p.id === targetUserId ? { ...p, isConnected: true } : p
      );
    });

    peer.on('error', (error: Error) => {
      console.error(`‚ùå [PEER] - Erreur avec le peer ${targetUserId}:`, error);
    });

    peer.on('close', () => {
      console.log(`üîí [PEER] - Connexion ferm√©e avec ${targetUserId}`);
      // Nettoyer le peer ferm√©
      setPeers(prev => prev.filter(p => p.id !== targetUserId));
      peersRef.current = peersRef.current.filter(p => p.id !== targetUserId);
      pendingSignalsRef.current.delete(targetUserId);
    });

    peer.on('stream', (remoteStream: MediaStream) => {
      console.log(`üìπ [PEER] - Flux distant re√ßu de ${targetUserId}`);
    });

    return peer;
  };

  const addPeer = (incomingSignal: PeerSignalData, callerId: string, stream: MediaStream): PeerInstance => {
    console.log(`üì• [PEER] - Ajout d'un peer pour r√©pondre √† ${callerId}`);
    
    const peer: PeerInstance = new SimplePeer.default({
      initiator: false,
      trickle: false,
      stream: stream || undefined,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:global.stun.twilio.com:3478' }
        ]
      }
    });
    
    peer.on('signal', (signal: PeerSignalData) => {
      console.log(`‚úÖ [PEER] - Envoi du signal de retour de ${currentUserId} √† ${callerId}`);
      signalViaAPI({
        channelName: `presence-session-${sessionId}`,
        userId: currentUserId,
        target: callerId,
        signal,
        isReturnSignal: true,
      });
    });

    peer.on('connect', () => {
      console.log(`üîó [PEER] - Connexion r√©ponse √©tablie avec ${callerId}`);
      setPeers(prev => prev.map(p => 
        p.id === callerId ? { ...p, isConnected: true } : p
      ));
      peersRef.current = peersRef.current.map(p => 
        p.id === callerId ? { ...p, isConnected: true } : p
      );
    });

    peer.on('error', (error: Error) => {
      console.error(`‚ùå [PEER] - Erreur avec le peer r√©ponse ${callerId}:`, error);
    });

    peer.on('stream', (remoteStream: MediaStream) => {
      console.log(`üìπ [PEER] - Flux distant re√ßu de ${callerId}`);
    });

    // Appliquer le signal initial apr√®s un petit d√©lai
    setTimeout(() => {
      try {
        console.log(`üéØ [PEER] - Application du signal initial √† ${callerId}`);
        peer.signal(incomingSignal);
      } catch (error) {
        console.error(`‚ùå [PEER] - Erreur lors de l'application du signal initial √† ${callerId}:`, error);
      }
    }, 500);
    
    return peer;
  };

  // Fonction pour traiter les signaux en attente
  const processPendingSignals = (userId: string, peer: PeerInstance): void => {
    const pending = pendingSignalsRef.current.get(userId);
    if (pending && pending.length > 0) {
      console.log(`üì® [SIGNAL] - Traitement de ${pending.length} signaux en attente pour ${userId}`);
      pending.forEach(signal => {
        try {
          peer.signal(signal);
        } catch (error) {
          console.error(`‚ùå [SIGNAL] - Erreur lors de l'application du signal en attente:`, error);
        }
      });
      pendingSignalsRef.current.delete(userId);
    }
  };

  // ---=== GESTION DU MINUTEUR ===---
  const handleStartTimer = (): void => {
    broadcastTimerEvent(sessionId, 'timer-started');
  };

  const handlePauseTimer = (): void => {
    broadcastTimerEvent(sessionId, 'timer-paused');
  };

  const handleResetTimer = (): void => {
    broadcastTimerEvent(sessionId, 'timer-reset', { duration: timerDuration });
  };

  useEffect(() => {
    if (isTimerRunning && timerTimeLeft > 0) {
      timerIntervalRef.current = setInterval(() => {
        setTimerTimeLeft(prev => prev - 1);
      }, 1000);
    } else if (!isTimerRunning || timerTimeLeft === 0) {
      if (timerIntervalRef.current) {
        clearInterval(timerIntervalRef.current);
        timerIntervalRef.current = null;
      }
    }

    return (): void => {
      if (timerIntervalRef.current) {
        clearInterval(timerIntervalRef.current);
        timerIntervalRef.current = null;
      }
    };
  }, [isTimerRunning, timerTimeLeft]);
  
  // ---=== 3. GESTION DES √âV√âNEMENTS PUSHER CORRIG√âE ===---
  useEffect(() => {
    // Ne pas initialiser sans sessionId
    if (!sessionId) return;

    const channelName = `presence-session-${sessionId}`;
    
    // V√©rifier si d√©j√† abonn√©
    if (pusherClient.channel(channelName)) {
      console.log(`‚è≠Ô∏è [PUSHER] - D√©j√† abonn√© au canal ${channelName}`);
      return;
    }

    const channel = pusherClient.subscribe(channelName);
    channelRef.current = channel;
    
    // Initialisation quand on rejoint
    const handleSubscriptionSucceeded = (members: PusherSubscriptionSucceededEvent): void => {
      const otherUsers = Object.keys(members.members || {}).filter(id => id !== currentUserId);
      setOnlineUserIds(Object.keys(members.members || {}));
      console.log(`‚úÖ [PUSHER] - Abonnement r√©ussi √† la session ${sessionId}. Participants:`, otherUsers);
      
      // Attendre que le flux local soit disponible avant de cr√©er les peers
      if (!localStream) {
        console.log('‚è≥ [PUSHER] - En attente du flux local...');
        return;
      }
      
      // Cr√©er des connexions peer avec tous les utilisateurs existants
      const newPeers: PeerData[] = otherUsers.map(userId => {
        const peer = createPeer(userId, true, localStream);
        return { id: userId, peer, isConnected: false };
      });
      
      setPeers(newPeers);
      peersRef.current = newPeers;
    };

    // Quand un nouvel utilisateur rejoint
    const handleMemberAdded = (member: PusherMemberEvent): void => {
      if (member.id === currentUserId) return;
      console.log(`‚ûï [PUSHER] - Nouveau participant rejoint: ${member.id}`);
      
      setOnlineUserIds(prevUserIds => {
        if (!prevUserIds.includes(member.id)) {
          return [...prevUserIds, member.id];
        }
        return prevUserIds;
      });

      // Cr√©er une connexion peer avec le nouvel utilisateur
      if (!peersRef.current.find(p => p.id === member.id) && localStream) {
        const peer = createPeer(member.id, true, localStream);
        const newPeerData: PeerData = { id: member.id, peer, isConnected: false };
        
        setPeers(prev => [...prev.filter(p => p.id !== member.id), newPeerData]);
        peersRef.current = [...peersRef.current.filter(p => p.id !== member.id), newPeerData];
      }
    };

    // Gestion des signaux WebRTC - CORRECTION PRINCIPALE
    const handleSignal = (data: IncomingSignalData): void => {
      if (data.target !== currentUserId) return;
      if (data.userId === currentUserId) return; // Ignorer ses propres signaux
      
      console.log(`üì° [PUSHER] - Signal re√ßu de ${data.userId}. isReturnSignal: ${!!data.isReturnSignal}, Type: ${data.signal.type}`);
      
      // √âviter le traitement en double du m√™me signal
      const signalKey = `${data.userId}-${data.signal.type}-${Date.now()}`;
      if (isProcessingSignalRef.current.has(signalKey)) {
        console.log(`‚è≠Ô∏è [SIGNAL] - Signal d√©j√† en cours de traitement, ignor√©: ${signalKey}`);
        return;
      }
      
      isProcessingSignalRef.current.add(signalKey);
      
      setTimeout(() => {
        try {
          const existingPeer = peersRef.current.find(p => p.id === data.userId);

          if (!existingPeer) {
            // Cr√©er un nouveau peer pour r√©pondre
            if (data.isReturnSignal) {
              console.warn(`‚ö†Ô∏è [SIGNAL] - Signal de retour re√ßu mais aucun peer initiateur trouv√© pour ${data.userId}.`);
              return;
            }
            
            console.log(`üÜï [SIGNAL] - Cr√©ation d'un nouveau peer de r√©ponse pour ${data.userId}`);
            
            if (!localStream) {
              console.warn(`‚è≥ [SIGNAL] - Flux local non disponible, mise en attente du signal pour ${data.userId}`);
              // Stocker le signal en attente
              if (!pendingSignalsRef.current.has(data.userId)) {
                pendingSignalsRef.current.set(data.userId, []);
              }
              pendingSignalsRef.current.get(data.userId)!.push(data.signal);
              return;
            }
            
            const peer = addPeer(data.signal, data.userId, localStream);
            const newPeerData: PeerData = { id: data.userId, peer, isConnected: false };
            
            setPeers(prev => [...prev.filter(p => p.id !== data.userId), newPeerData]);
            peersRef.current = [...peersRef.current.filter(p => p.id !== data.userId), newPeerData];
            
          } else {
            // Peer existe d√©j√† - appliquer le signal
            console.log(`üéØ [SIGNAL] - Application du signal au peer existant pour ${data.userId}`);
            
            try {
              existingPeer.peer.signal(data.signal);
              
              // Traiter les signaux en attente apr√®s l'application r√©ussie
              if (data.signal.type === 'answer' || data.signal.type === 'offer') {
                processPendingSignals(data.userId, existingPeer.peer);
              }
            } catch (error) {
              console.error(`‚ùå [SIGNAL] - Erreur lors de l'application du signal √† ${data.userId}:`, error);
              
              // En cas d'erreur, mettre le signal en attente
              if (!pendingSignalsRef.current.has(data.userId)) {
                pendingSignalsRef.current.set(data.userId, []);
              }
              pendingSignalsRef.current.get(data.userId)!.push(data.signal);
            }
          }
        } catch (error) {
          console.error(`‚ùå [SIGNAL] - Erreur critique lors du traitement du signal de ${data.userId}:`, error);
        } finally {
          // Nettoyer apr√®s un d√©lai
          setTimeout(() => {
            isProcessingSignalRef.current.delete(signalKey);
          }, 1000);
        }
      }, 100);
    };

    // Quand un utilisateur quitte
    const handleMemberRemoved = (member: PusherMemberEvent): void => {
      console.log(`‚ûñ [PUSHER] - Participant parti: ${member.id}`);
      setOnlineUserIds(prev => prev.filter(id => id !== member.id));
      
      const peerToRemove = peersRef.current.find(p => p.id === member.id);
      if (peerToRemove) {
        peerToRemove.peer.destroy();
        setPeers(prev => prev.filter(p => p.id !== member.id));
        peersRef.current = peersRef.current.filter(p => p.id !== member.id);
        pendingSignalsRef.current.delete(member.id);
      }
    };

    const handleSessionEnded = (): void => {
      console.log('üîö [PUSHER] - √âv√©nement de fin de session re√ßu.');
      toast({ title: 'Session termin√©e', description: 'Le professeur a mis fin √† la session.' });
      router.push(currentUserRole === 'PROFESSEUR' ? '/teacher/dashboard' : '/student/dashboard');
    };

    const handleParticipantSpotlighted = (data: SpotlightEvent): void => {
      console.log(`üåü [PUSHER] - Mise en vedette de ${data.participantId}`);
      setSpotlightedParticipantId(data.participantId);
    };

    const handleHandRaiseUpdate = (data: HandRaiseEvent): void => {
      console.log(`‚úã [PUSHER] - Main ${data.isRaised ? 'lev√©e' : 'baiss√©e'} par ${data.userId}`);
      setRaisedHands(prev => {
        const newSet = new Set(prev);
        data.isRaised ? newSet.add(data.userId) : newSet.delete(data.userId);
        return newSet;
      });
    };

    const handleUnderstandingUpdate = (data: UnderstandingEvent): void => {
      console.log(`ü§î [PUSHER] - Statut de compr√©hension de ${data.userId} : ${data.status}`);
      setUnderstandingStatus(prev => new Map(prev).set(data.userId, data.status));
    };

    const handleTimerStarted = (): void => setIsTimerRunning(true);
    const handleTimerPaused = (): void => setIsTimerRunning(false);
    
    const handleTimerReset = (data: TimerEvent): void => {
      setIsTimerRunning(false);
      setTimerTimeLeft(data.duration || INITIAL_TIMER_DURATION);
      setTimerDuration(data.duration || INITIAL_TIMER_DURATION);
    };

    const handleActiveToolChanged = (data: ToolEvent): void => {
      console.log(`[PUSHER] Active tool changed to: ${data.tool}`);
      setActiveTool(data.tool);
    };

    const handleDocumentUpdated = (data: DocumentEvent): void => {
      console.log(`[PUSHER] Document URL updated: ${data.url}`);
      setDocumentUrl(data.url);
      setActiveTool('document');
      toast({ title: 'Document partag√©', description: 'Le professeur a partag√© un nouveau document.' });
    };

    const handleWhiteboardUpdate = (data: { senderId: string, snapshot: TLStoreSnapshot }) => {
        if (data.senderId !== currentUserId) {
            console.log(`üé® [PUSHER] - Mise √† jour du tableau blanc re√ßue de ${data.senderId}`);
            setWhiteboardSnapshot(data.snapshot);
        }
    };


    // Lier les √©v√©nements
    channel.bind('pusher:subscription_succeeded', handleSubscriptionSucceeded);
    channel.bind('pusher:member_added', handleMemberAdded);
    channel.bind('pusher:member_removed', handleMemberRemoved);
    channel.bind('signal', handleSignal);
    channel.bind('session-ended', handleSessionEnded);
    channel.bind('participant-spotlighted', handleParticipantSpotlighted);
    channel.bind('hand-raise-update', handleHandRaiseUpdate);
    channel.bind('understanding-update', handleUnderstandingUpdate);
    channel.bind('timer-started', handleTimerStarted);
    channel.bind('timer-paused', handleTimerPaused);
    channel.bind('timer-reset', handleTimerReset);
    channel.bind('active-tool-changed', handleActiveToolChanged);
    channel.bind('document-updated', handleDocumentUpdated);
    channel.bind('whiteboard-update', handleWhiteboardUpdate);

    return (): void => {
      console.log(`üîå [PUSHER] - Nettoyage des abonnements pour la session ${sessionId}`);
      
      // D√©tacher tous les √©couteurs
      channel.unbind_all();
      
      pusherClient.unsubscribe(channelName);
      
      // Nettoyer tous les peers
      peersRef.current.forEach(({ peer }) => {
        try {
          peer.destroy();
        } catch (error) {
          console.warn('Erreur lors de la destruction du peer:', error);
        }
      });
      peersRef.current = [];
      pendingSignalsRef.current.clear();
    };
  }, [sessionId, localStream, currentUserId, router, toast, currentUserRole]);


// Dans le useEffect de gestion Pusher dans SessionClient.tsx, ajouter :

// V√©rifier si l'utilisateur est toujours dans la session
useEffect(() => {
  const handleBeforeUnload = (event: BeforeUnloadEvent) => {
    // Emp√™cher la fermeture imm√©diate
    event.preventDefault();
    event.returnValue = '';
  };

  const handleVisibilityChange = () => {
    if (document.visibilityState === 'hidden') {
      console.log('üëÄ [SESSION] - Page devenue invisible');
    } else {
      console.log('üëÄ [SESSION] - Page redevenue visible');
    }
  };

  window.addEventListener('beforeunload', handleBeforeUnload);
  document.addEventListener('visibilitychange', handleVisibilityChange);

  return () => {
    window.removeEventListener('beforeunload', handleBeforeUnload);
    document.removeEventListener('visibilitychange', handleVisibilityChange);
  };
}, []);

// Et dans la gestion des membres ajout√©s, ajouter un d√©lai :
const handleMemberAdded = (member: PusherMemberEvent): void => {
  if (member.id === currentUserId) return;
  console.log(`‚ûï [PUSHER] - Nouveau participant rejoint: ${member.id}`);
  
  // Attendre un peu avant de cr√©er le peer pour s'assurer que l'utilisateur reste
  setTimeout(() => {
    setOnlineUserIds(prevUserIds => {
      if (!prevUserIds.includes(member.id)) {
        return [...prevUserIds, member.id];
      }
      return prevUserIds;
    });

    // Cr√©er une connexion peer avec le nouvel utilisateur
    if (!peersRef.current.find(p => p.id === member.id) && localStream) {
      const peer = createPeer(member.id, true, localStream);
      const newPeerData: PeerData = { id: member.id, peer, isConnected: false };
      
      setPeers(prev => [...prev.filter(p => p.id !== member.id), newPeerData]);
      peersRef.current = [...peersRef.current.filter(p => p.id !== member.id), newPeerData];
    }
  }, 1000); // D√©lai de 1 seconde
};

  // Recr√©er les peers quand le flux local devient disponible
  useEffect(() => {
    if (localStream && peersRef.current.length > 0) {
      console.log('üîÑ [PEER] - Flux local disponible, recr√©ation des peers...');
      
      // Recr√©er tous les peers avec le nouveau flux
      const newPeers: PeerData[] = peersRef.current.map(({ id }) => {
        const peer = createPeer(id, true, localStream);
        return { id, peer, isConnected: false };
      });
      
      setPeers(newPeers);
      peersRef.current = newPeers;
    }
  }, [localStream]);

  const onSpotlightParticipant = useCallback(async (participantId: string): Promise<void> => {
    if (currentUserRole !== 'PROFESSEUR') return;
    try {
      await fetch(`/api/session/${sessionId}/spotlight`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ participantId }),
      });
    } catch (error) {
      toast({ variant: 'destructive', title: 'Erreur', description: 'Impossible de mettre le participant en vedette.' });
    }
  }, [sessionId, currentUserRole, toast]);
  
  const handleEndSession = useCallback(async (): Promise<void> => {
    if (currentUserRole !== 'PROFESSEUR') return;
    setIsEndingSession(true);
    try {
      const result = await endCoursSession(sessionId);
      if (result.success) {
        toast({ title: 'Session termin√©e', description: 'Vous allez √™tre redirig√©.' });
      } else {
        throw new Error("L'action serveur a √©chou√©.");
      }
    } catch (error) {
      toast({ variant: 'destructive', title: 'Erreur', description: 'Impossible de terminer la session.' });
    } finally {
      setIsEndingSession(false);
    }
  }, [currentUserRole, sessionId, toast]);

  const handleLeaveSession = useCallback((): void => {
    console.log('üö™ [CLIENT] - D√©part de la session demand√©');
    localStream?.getTracks().forEach(track => track.stop());
    peersRef.current.forEach(({ peer }) => {
      try {
        peer.destroy();
      } catch (error) {
        console.warn('Erreur lors de la destruction du peer:', error);
      }
    });
    
    if (channelRef.current) {
      const channelName = `presence-session-${sessionId}`;
      console.log(`üîå [PUSHER] - D√©sabonnement manuel du canal ${channelName}`);
      pusherClient.unsubscribe(channelName);
      channelRef.current = null;
    }

    router.push(currentUserRole === 'PROFESSEUR' ? '/teacher/dashboard' : '/student/dashboard');
  }, [localStream, router, currentUserRole, sessionId]);

  // Logique pour d√©terminer le flux √† afficher en vedette
  const spotlightedPeer = peers.find(p => p.id === spotlightedParticipantId);
  const spotlightedStream = spotlightedParticipantId === currentUserId 
    ? localStream 
    : spotlightedPeer?.peer.streams?.[0] || null;

  if (loading) {
    return <SessionLoading />;
  }

  const handleToggleHandRaise = (isRaised: boolean): void => {
    setRaisedHands(prev => {
      const newSet = new Set(prev);
      isRaised ? newSet.add(currentUserId) : newSet.delete(currentUserId);
      return newSet;
    });
  };

  const handleUnderstandingChange = (status: ComprehensionLevel): void => {
    setUnderstandingStatus(prev => new Map(prev).set(currentUserId, status));
  };

  const handleToolChange = (tool: string): void => {
    setActiveTool(tool);
    broadcastActiveTool(sessionId, tool);
  };

  const formatTime = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  // Pr√©parer les participants distants pour la vue professeur
  const remoteParticipants: RemoteParticipant[] = peers.map(p => ({ 
    id: p.id, 
    stream: p.peer.streams?.[0] 
  }));

  const spotlightedUser: SessionParticipant | undefined = allSessionUsers.find(u => u.id === spotlightedParticipantId);

  return (
    <div className="flex flex-col h-screen bg-background">
      <SessionHeader 
        sessionId={sessionId} 
        isTeacher={currentUserRole === 'PROFESSEUR'}
        onEndSession={handleEndSession}
        onLeaveSession={handleLeaveSession}
        isEndingSession={isEndingSession}
        isSharingScreen={!!screenStream}
        onToggleScreenShare={toggleScreenShare}
        initialDuration={timerDuration}
        timerTimeLeft={timerTimeLeft}
        isTimerRunning={isTimerRunning}
        onStartTimer={handleStartTimer}
        onPauseTimer={handlePauseTimer}
        onResetTimer={handleResetTimer}
      />
      <main className="flex-1 flex flex-col container mx-auto px-4 sm:px-6 lg:px-8 min-h-0">
        <PermissionPrompt />
        {currentUserRole === 'PROFESSEUR' ? (
          <TeacherSessionView
            sessionId={sessionId}
            localStream={localStream}
            screenStream={screenStream}
            remoteParticipants={remoteParticipants}
            spotlightedUser={spotlightedUser}
            allSessionUsers={allSessionUsers}
            onlineUserIds={onlineUserIds}
            onSpotlightParticipant={onSpotlightParticipant}
            raisedHands={raisedHands}
            understandingStatus={understandingStatus}
            currentUserId={currentUserId}
            onScreenShare={toggleScreenShare}
            isScreenSharing={!!screenStream}
            activeTool={activeTool}
            onToolChange={handleToolChange}
            classroom={classroom}
            documentUrl={documentUrl}
          />
        ) : (
          <StudentSessionView
            sessionId={sessionId}
            localStream={localStream}
            spotlightedStream={spotlightedStream}
            spotlightedUser={spotlightedUser}
            isHandRaised={raisedHands.has(currentUserId)}
            onToggleHandRaise={handleToggleHandRaise}
            onUnderstandingChange={handleUnderstandingChange}
            onLeaveSession={handleLeaveSession}
            currentUnderstanding={understandingStatus.get(currentUserId) || ComprehensionLevel.NONE}
            currentUserId={currentUserId}
            activeTool={activeTool}
            documentUrl={documentUrl}
            whiteboardSnapshot={whiteboardSnapshot}
          />
        )}
      </main>
    </div>
  );
}
