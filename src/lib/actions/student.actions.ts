// src/lib/actions/student.actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import prisma from '../prisma';
import getClient from '../redis';

const STUDENT_DATA_CACHE_KEY = (id: string) => `student:${id}`;

export async function getStudentData(id: string) {
    console.log(`üßë‚Äçüéì [ACTION] getStudentData pour l'ID: ${id}`);
    if (!id) {
        console.error('‚ùå [ACTION] ID manquant pour getStudentData');
        return null;
    }

    const redis = await getClient();
    
    // ‚úÖ CORRECTION: V√©rifier que redis n'est pas null avant de l'utiliser
    if (redis) {
        const cacheKey = STUDENT_DATA_CACHE_KEY(id);
        try {
            const cachedData = await redis.get(cacheKey);
            if (cachedData) {
                console.log(`‚ö°Ô∏è [CACHE] Donn√©es pour l'√©l√®ve ${id} servies depuis Redis.`);
                return JSON.parse(cachedData);
            }
        } catch (error) {
            console.error('‚ö†Ô∏è [ACTION] Erreur de lecture du cache Redis (non bloquant):', error);
        }
    } else {
        console.log('‚ö†Ô∏è [ACTION] Redis non disponible, lecture directe depuis la base de donn√©es');
    }
    
    console.log(`üßë‚Äçüéì [DB] R√©cup√©ration des donn√©es pour l'√©l√®ve ID: ${id}`);
    
    try {
        const student = await prisma.user.findUnique({
            where: { id },
            include: {
                classe: true,
                etat: {
                    include: {
                        metier: true
                    }
                },
                studentProgress: true,
            }
        });

        if (!student) {
            console.error(`‚ùå [ACTION] √âl√®ve non trouv√© avec l'ID: ${id}`);
            return null;
        }

        if (student.role !== 'ELEVE') {
            console.error(`‚ùå [ACTION] L'utilisateur ${id} n'est pas un √©l√®ve (r√¥le: ${student.role})`);
            return null;
        }

        console.log(`‚úÖ [ACTION] Donn√©es charg√©es pour l'√©l√®ve: ${student.name} (classe: ${student.classe?.nom || 'Aucune'})`);

        // ‚úÖ CORRECTION: V√©rifier que redis n'est pas null avant la mise en cache
        if (redis) {
            const cacheKey = STUDENT_DATA_CACHE_KEY(id);
            try {
                // Mettre en cache les donn√©es avec une expiration de 1 heure
                await redis.set(cacheKey, JSON.stringify(student), 'EX', 3600);
                console.log(`üíæ [ACTION] Donn√©es mises en cache pour l'√©l√®ve ${id}`);
            } catch (error) {
                console.error('‚ö†Ô∏è [ACTION] Erreur d\'√©criture du cache Redis (non bloquant):', error);
            }
        }

        return student;

    } catch (error) {
        console.error(`‚ùå [ACTION] Erreur base de donn√©es pour l'√©l√®ve ${id}:`, error);
        return null;
    }
}

export async function setStudentCareer(studentId: string, careerId: string | null): Promise<{ success: boolean; error?: string }> {
    console.log(`üé® [ACTION] setStudentCareer pour l'√©l√®ve ${studentId} vers le m√©tier ${careerId}`);

    try {
        const student = await prisma.user.findUnique({
            where: { id: studentId },
            select: { 
                id: true, 
                role: true, 
                classeId: true
            }
        });

        if (!student || student.role !== 'ELEVE') {
            throw new Error('√âl√®ve non trouv√© ou non autoris√©');
        }

        // V√©rifier que le m√©tier existe si careerId n'est pas null
        if (careerId) {
            const career = await prisma.metier.findUnique({
                where: { id: careerId },
                select: { id: true }
            });
            
            if (!career) {
                throw new Error('M√©tier non trouv√©');
            }
        }

        // Mettre √† jour le m√©tier de l'√©l√®ve
        await prisma.etatEleve.upsert({
            where: { eleveId: studentId },
            update: {
                metierId: careerId,
            },
            create: {
                eleveId: studentId,
                metierId: careerId,
            }
        });
        
        console.log(`‚úÖ [ACTION] M√©tier mis √† jour pour l'√©l√®ve ${studentId}`);

        // ‚úÖ CORRECTION: V√©rifier que redis n'est pas null avant l'invalidation
        const redis = await getClient();
        if (redis) {
            try {
                await redis.del(STUDENT_DATA_CACHE_KEY(studentId));
                console.log(`üîÑ [ACTION] Cache Redis pour l'√©l√®ve ${studentId} invalid√©.`);
            } catch(error) {
                console.error('‚ö†Ô∏è [ACTION] Erreur d\'invalidation du cache Redis (non bloquant):', error);
            }
        } else {
            console.log('‚ö†Ô∏è [ACTION] Redis non disponible, pas d\'invalidation du cache');
        }
        
        // Revalider les pages concern√©es
        revalidatePath('/student/dashboard');
        revalidatePath(`/student/${studentId}`);
        if (student.classeId) {
            revalidatePath(`/teacher/class/${student.classeId}`);
        }

        return { success: true };

    } catch (error) {
        console.error(`‚ùå [ACTION] Erreur lors du changement de m√©tier pour ${studentId}:`, error);
        return { 
            success: false, 
            error: error instanceof Error ? error.message : 'Erreur lors du changement de m√©tier' 
        };
    }
}

// Fonction utilitaire pour obtenir les progr√®s de l'√©l√®ve
export async function getStudentProgress(studentId: string) {
    console.log(`üìà [ACTION] getStudentProgress pour l'√©l√®ve: ${studentId}`);
    try {
        const progress = await prisma.studentProgress.findMany({
            where: { studentId },
            include: {
                task: true
            },
            orderBy: {
                completionDate: 'desc'
            }
        });
        console.log(`  -> ${progress.length} entr√©es de progression trouv√©es.`);
        return progress;
    } catch (error) {
        console.error(`‚ùå [ACTION] Erreur lors de la r√©cup√©ration des progr√®s pour ${studentId}:`, error);
        return [];
    }
}

// Fonction pour r√©cup√©rer les d√©tails complets d'un √©l√®ve
export async function getStudentDetails(studentId: string) {
    console.log(`‚ÑπÔ∏è [ACTION] getStudentDetails pour l'√©l√®ve: ${studentId}`);
    try {
        const student = await prisma.user.findUnique({
            where: { id: studentId },
            include: {
                classe: {
                    include: {
                        professeur: {
                            select: {
                                id: true,
                                name: true,
                                email: true
                            }
                        }
                    }
                },
                etat: {
                    include: {
                        metier: true
                    }
                },
                studentProgress: {
                    include: {
                        task: true
                    },
                    orderBy: {
                        completionDate: 'desc'
                    }
                }
            }
        });

        if (!student || student.role !== 'ELEVE') {
            console.log(`  -> √âl√®ve non trouv√© ou r√¥le incorrect.`);
            return null;
        }

        console.log(`‚úÖ [ACTION] D√©tails complets r√©cup√©r√©s pour ${studentId}.`);
        return student;
    } catch (error) {
        console.error(`‚ùå [ACTION] Erreur lors de la r√©cup√©ration des d√©tails pour ${studentId}:`, error);
        return null;
    }
}