// src/lib/actions/student.actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import prisma from '../prisma';
import redis from '../redis';

const STUDENT_DATA_CACHE_KEY = (id: string) => `student:${id}`;

export async function getStudentData(id: string) {
    if (!id) {
        console.error('‚ùå [STUDENT ACTIONS] ID manquant pour getStudentData');
        return null;
    }

    const cacheKey = STUDENT_DATA_CACHE_KEY(id);
    
    // Tentative de r√©cup√©ration depuis le cache
    if (redis) {
        try {
            const cachedData = await redis.get(cacheKey);
            if (cachedData) {
                console.log(`‚ö°Ô∏è [CACHE] Donn√©es pour l'√©l√®ve ${id} servies depuis Redis.`);
                return JSON.parse(cachedData);
            }
        } catch (error) {
            console.error('‚ö†Ô∏è [STUDENT ACTIONS] Erreur de lecture du cache Redis (non bloquant):', error);
        }
    }
    
    console.log(`üßë‚Äçüéì [DB] R√©cup√©ration des donn√©es pour l'√©l√®ve ID: ${id}`);
    
    try {
        const student = await prisma.user.findUnique({
            where: { id },
            include: {
                classe: true,
                etat: {
                    include: {
                        metier: true
                    }
                },
                studentProgress: true,
            }
        });

        if (!student) {
            console.error(`‚ùå [STUDENT ACTIONS] √âl√®ve non trouv√© avec l'ID: ${id}`);
            return null;
        }

        if (student.role !== 'ELEVE') {
            console.error(`‚ùå [STUDENT ACTIONS] L'utilisateur ${id} n'est pas un √©l√®ve (r√¥le: ${student.role})`);
            return null;
        }

        console.log(`‚úÖ [STUDENT ACTIONS] Donn√©es charg√©es pour l'√©l√®ve: ${student.name} (classe: ${student.classe?.nom || 'Aucune'})`);

        // Mise en cache des donn√©es
        if (redis) {
            try {
                // Mettre en cache les donn√©es avec une expiration de 1 heure
                await redis.set(cacheKey, JSON.stringify(student), 'EX', 3600);
                console.log(`üíæ [STUDENT ACTIONS] Donn√©es mises en cache pour l'√©l√®ve ${id}`);
            } catch (error) {
                console.error('‚ö†Ô∏è [STUDENT ACTIONS] Erreur d\'√©criture du cache Redis (non bloquant):', error);
            }
        }

        return student;

    } catch (error) {
        console.error(`‚ùå [STUDENT ACTIONS] Erreur base de donn√©es pour l'√©l√®ve ${id}:`, error);
        return null;
    }
}

export async function setStudentCareer(studentId: string, careerId: string | null): Promise<{ success: boolean; error?: string }> {
    console.log(`üé® [ACTION] Changement de m√©tier pour l'√©l√®ve ${studentId} vers le m√©tier ${careerId}`);

    try {
        const student = await prisma.user.findUnique({
            where: { id: studentId },
            select: { 
                id: true, 
                role: true, 
                classeId: true
            }
        });

        if (!student || student.role !== 'ELEVE') {
            throw new Error('√âl√®ve non trouv√© ou non autoris√©');
        }

        // V√©rifier que le m√©tier existe si careerId n'est pas null
        if (careerId) {
            const career = await prisma.metier.findUnique({
                where: { id: careerId },
                select: { id: true }
            });
            
            if (!career) {
                throw new Error('M√©tier non trouv√©');
            }
        }

        // Mettre √† jour le m√©tier de l'√©l√®ve
        await prisma.etatEleve.upsert({
            where: { eleveId: studentId },
            update: {
                metierId: careerId,
            },
            create: {
                eleveId: studentId,
                metierId: careerId,
            }
        });
        
        console.log(`‚úÖ [STUDENT ACTIONS] M√©tier mis √† jour pour l'√©l√®ve ${studentId}`);

        // Invalider le cache de l'√©l√®ve
        if (redis) {
            try {
                await redis.del(STUDENT_DATA_CACHE_KEY(studentId));
                console.log(`üîÑ [STUDENT ACTIONS] Cache Redis pour l'√©l√®ve ${studentId} invalid√©.`);
            } catch(error) {
                console.error('‚ö†Ô∏è [STUDENT ACTIONS] Erreur d\'invalidation du cache Redis (non bloquant):', error);
            }
        }
        
        // Revalider les pages concern√©es
        revalidatePath('/student/dashboard');
        revalidatePath(`/student/${studentId}`);
        if (student.classeId) {
            revalidatePath(`/teacher/class/${student.classeId}`);
        }

        return { success: true };

    } catch (error) {
        console.error(`‚ùå [STUDENT ACTIONS] Erreur lors du changement de m√©tier pour ${studentId}:`, error);
        return { 
            success: false, 
            error: error instanceof Error ? error.message : 'Erreur lors du changement de m√©tier' 
        };
    }
}

// Fonction utilitaire pour obtenir les progr√®s de l'√©l√®ve
export async function getStudentProgress(studentId: string) {
    try {
        const progress = await prisma.studentProgress.findMany({
            where: { studentId },
            include: {
                task: true
            },
            orderBy: {
                completionDate: 'desc'
            }
        });

        return progress;
    } catch (error) {
        console.error(`‚ùå [STUDENT ACTIONS] Erreur lors de la r√©cup√©ration des progr√®s pour ${studentId}:`, error);
        return [];
    }
}

// Fonction pour r√©cup√©rer les d√©tails complets d'un √©l√®ve
export async function getStudentDetails(studentId: string) {
    try {
        const student = await prisma.user.findUnique({
            where: { id: studentId },
            include: {
                classe: {
                    include: {
                        professeur: {
                            select: {
                                id: true,
                                name: true,
                                email: true
                            }
                        }
                    }
                },
                etat: {
                    include: {
                        metier: true
                    }
                },
                studentProgress: {
                    include: {
                        task: true
                    },
                    orderBy: {
                        completionDate: 'desc'
                    }
                }
            }
        });

        if (!student || student.role !== 'ELEVE') {
            return null;
        }

        return student;
    } catch (error) {
        console.error(`‚ùå [STUDENT ACTIONS] Erreur lors de la r√©cup√©ration des d√©tails pour ${studentId}:`, error);
        return null;
    }
}
