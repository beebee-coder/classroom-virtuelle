// src/lib/actions/activity.actions.ts
'use server';

import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth-options";
import prisma from '../prisma';

const POINTS_PER_INTERVAL = 1; // R√©duit pour une accumulation plus lente
const MAX_DAILY_POINTS = 50;

/**
 * Suivi de l'activit√© de l'√©l√®ve. A appeler p√©riodiquement (heartbeat).
 * Attribue des points pour l'activit√©.
 */
export async function trackStudentActivity(activeSeconds: number) {
  const session = await getServerSession(authOptions);
  
  // 1. V√©rification robuste de la session et du r√¥le
  if (!session?.user?.id || session.user.role !== 'ELEVE') {
    console.log('üë§ [HEARTBEAT] Action ignor√©e: Non-√©l√®ve ou non authentifi√©.');
    return { success: true, pointsAwarded: 0, reason: 'Not an authenticated student' };
  }
  
  const userId = session.user.id;
  console.log(`üíì [HEARTBEAT] Ping re√ßu pour l'√©l√®ve ${userId}.`);

  try {
    // 2. Logique d'attribution de points
    const pointsToAward = POINTS_PER_INTERVAL;
    
    // Mettre √† jour les points de l'√©l√®ve
    const updatedUser = await prisma.user.update({
        where: { id: userId },
        data: { points: { increment: pointsToAward } }
    });

    console.log(`üí∞ [HEARTBEAT] Effet: +${pointsToAward} points pour ${userId}. Total: ${updatedUser.points}`);

    return { 
      success: true, 
      pointsAwarded: pointsToAward,
      dailyPoints: updatedUser.points, // Le total est retourn√© pour la d√©mo
    };

  } catch (error) {
    console.error(`‚ùå [HEARTBEAT] Erreur pour l'√©l√®ve ${userId}:`, error);
    // Ne pas lancer d'erreur pour ne pas casser le client, juste retourner un √©chec.
    return { success: false, error: 'Failed to track activity.' };
  }
}
