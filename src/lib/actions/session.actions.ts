// src/lib/actions/session.actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { pusherTrigger } from '../pusher/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import prisma from '../prisma';
import type { CoursSession, User } from '@prisma/client';
import { Role } from '@prisma/client';
import { ComprehensionLevel } from '@/lib/types';



export async function createCoursSession(professeurId: string, classroomId: string, studentIds: string[]) {
    console.log('üöÄ [ACTION SESSION] - D√©but de la cr√©ation de la session de cours...');
    try {
        console.log(`  Cr√©ation pour prof ${professeurId}, classe ${classroomId} avec ${studentIds.length} √©l√®ve(s).`);
        
        if (!professeurId || !classroomId || !studentIds || !Array.isArray(studentIds)) {
             console.error('‚ùå [ACTION SESSION] - Param√®tres invalides.');
            throw new Error('Param√®tres invalides: professeurId, classroomId et studentIds sont requis');
        }
        const participantIds = [professeurId, ...studentIds];

        // Cr√©er la session et connecter les participants dans une seule transaction
        const session = await prisma.coursSession.create({
            data: {
                professeurId: professeurId,
                classroomId: classroomId,
                participants: {
                    connect: participantIds.map(id => ({ id }))
                }
            },
            include: {
                participants: true
            }
        });

        console.log(`  Session ${session.id} et ses participants cr√©√©s en base de donn√©es.`);

        const invitationResults = await sendIndividualInvitations(session.id, professeurId, classroomId, studentIds);

        // Revalidate the path for each invited student
        studentIds.forEach(id => {
            console.log(`  Revalidation du chemin pour l'√©l√®ve: /student/${id}`);
            revalidatePath(`/student/dashboard`);
            revalidatePath(`/student/${id}`);
        });
        
        console.log('‚úÖ [ACTION SESSION] - Cr√©ation de session termin√©e avec succ√®s.');
        return { 
            id: session.id, 
            professeurId, 
            classroomId,
            invitationResults,
            success: true 
        };
        
    } catch (error) {
        console.error('üí• [ACTION SESSION] - Erreur critique lors de la cr√©ation:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec de la cr√©ation de session: ${error.message}`
                : 'Erreur inconnue lors de la cr√©ation de session'
        );
    }
}

async function sendIndividualInvitations(sessionId: string, professeurId: string, classroomId: string, studentIds: string[]) {
    console.log(`üì® [ACTION INVITATIONS] - D√©but de l'envoi pour la session ${sessionId}`);
    const results = {
        successful: [] as string[],
        failed: [] as string[]
    };

    const classroom = await prisma.classroom.findUnique({ where: { id: classroomId } });
    const teacher = await prisma.user.findUnique({ where: { id: professeurId } });

    const invitationPayload = {
        sessionId: sessionId,
        teacherId: professeurId,
        classroomId: classroomId,
        classroomName: classroom?.nom || 'Classe inconnue',
        teacherName: teacher?.name || 'Professeur',
        timestamp: new Date().toISOString(),
        type: 'session-invitation'
    };
    
    console.log('  Payload d\'invitation pr√©par√©:', invitationPayload);

    // Pas de stockage en m√©moire, Pusher g√®re la livraison en temps r√©el.
    // Pour les invitations manqu√©es, le client pourrait faire un appel pour voir si une session active pour sa classe existe.

    for (const studentId of studentIds) {
        const channelName = `private-user-${studentId}`;
        try {
            console.log(`  -> Envoi √† ${studentId} sur le canal ${channelName}`);
            await pusherTrigger(
                channelName, 
                'session-invitation', 
                invitationPayload
            );
            results.successful.push(studentId);
        } catch (error) {
            console.error(`  -> ‚ùå √âchec de l'envoi pour ${studentId}:`, error);
            results.failed.push(studentId);
        }
    }

    console.log(`üìä [ACTION INVITATIONS] - R√©sum√©: ${results.successful.length} succ√®s, ${results.failed.length} √©checs.`);
    return results;
}


export async function getSessionDetails(sessionId: string) {
    console.log(`‚ÑπÔ∏è [ACTION SESSION DETAILS] - R√©cup√©ration des d√©tails pour la session ${sessionId}`);
    try {
        if (!sessionId) {
            console.error('‚ùå [ACTION SESSION DETAILS] - sessionId est requis.');
            throw new Error('sessionId est requis');
        }

        const session = await prisma.coursSession.findUnique({
            where: { id: sessionId },
            include: {
                professeur: true,
                participants: true,
            }
        });

        if (!session) {
            console.error(`‚ùå [ACTION SESSION DETAILS] - Session non trouv√©e: ${sessionId}`);
            throw new Error('Session non trouv√©e.');
        }

        const students = session.participants
            .filter((p) => p.role === Role.ELEVE);

        console.log('‚úÖ [ACTION SESSION DETAILS] - D√©tails de session r√©cup√©r√©s.');
        return {
            id: session.id,
            teacher: session.professeur,
            students: students,
            documentHistory: [], // Retourne un tableau vide car la fonctionnalit√© est supprim√©e
        };
        
    } catch (error) {
        console.error('üí• [ACTION SESSION DETAILS] - Erreur:', error);
        throw new Error('Impossible de r√©cup√©rer les d√©tails de la session');
    }
}

export async function spotlightParticipant(sessionId: string, participantId: string) {
    console.log(`üåü [ACTION SPOTLIGHT] - Mise en vedette de ${participantId} dans la session ${sessionId}`);
    try {
        if (!sessionId || !participantId) {
            console.error('‚ùå [ACTION SPOTLIGHT] - sessionId et participantId sont requis.');
            throw new Error('sessionId et participantId sont requis');
        }
        const channelName = `presence-session-${sessionId}`;
        
        await pusherTrigger(
            channelName, 
            'participant-spotlighted', 
            { 
                participantId,
                sessionId,
                timestamp: new Date().toISOString()
            }
        );
        console.log(`  √âv√©nement 'participant-spotlighted' diffus√© sur ${channelName}.`);

        revalidatePath(`/session/${sessionId}`);
        console.log('‚úÖ [ACTION SPOTLIGHT] - Action termin√©e avec succ√®s.');
        return { success: true, participantId, sessionId };
        
    } catch (error) {
        console.error('üí• [ACTION SPOTLIGHT] - Erreur:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec du spotlight: ${error.message}`
                : 'Erreur inconnue lors du spotlight'
        );
    }
}

export async function endCoursSession(sessionId: string) {
    console.log(`üîö [ACTION END SESSION] - Tentative de fin de la session ${sessionId}`);
    try {
        if (!sessionId) {
            console.error('‚ùå [ACTION END SESSION] - sessionId est requis.');
            throw new Error('sessionId est requis');
        }

        const session = await prisma.coursSession.update({
            where: { id: sessionId },
            data: { endTime: new Date() }
        });

        const classroomId = session.classroomId;

        const eventData = { 
            sessionId,
            endedAt: new Date().toISOString()
        };
        
        const sessionChannel = `presence-session-${sessionId}`;
        console.log(`  -> Envoi de 'session-ended' au canal de session: ${sessionChannel}`);
        await pusherTrigger(sessionChannel, 'session-ended', eventData);
        
        if (classroomId) {
            const classChannel = `presence-classe-${classroomId}`;
            console.log(`  -> Envoi de 'session-ended' au canal de classe: ${classChannel}`);
            await pusherTrigger(classChannel, 'session-ended', eventData);
        }


        console.log('‚úÖ [ACTION END SESSION] - Session termin√©e avec succ√®s.');
        return { 
            id: sessionId, 
            success: true 
        };
        
    } catch (error) {
        console.error('üí• [ACTION END SESSION] - Erreur:', error);
        throw new Error('Impossible de terminer la session');
    }
}
export async function serverSpotlightParticipant(sessionId: string, participantId: string) {
    console.log(`üåü [ACTION SPOTLIGHT - SERVER] - Ex√©cution de la mise en vedette pour ${participantId}.`);
    return await spotlightParticipant(sessionId, participantId);
}

export async function broadcastTimerEvent(sessionId: string, event: string, data?: any) {
    console.log(`‚è±Ô∏è [ACTION TIMER] - Diffusion de l'√©v√©nement '${event}' pour la session ${sessionId}`);
    try {
        if (!sessionId || !event) {
            console.error('‚ùå [ACTION TIMER] - sessionId et event sont requis.');
            throw new Error('sessionId et event sont requis');
        }
        const channel = `presence-session-${sessionId}`;
        
        const payload = { 
            ...data,
            sessionId,
            timestamp: new Date().toISOString()
        };
        console.log(`  Payload diffus√© sur ${channel}:`, payload);
        await pusherTrigger(
            channel, 
            event, 
            payload
        );
        
        return { success: true, event, sessionId };
        
    } catch (error) {
        console.error('üí• [ACTION TIMER] - Erreur:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec de la diffusion timer: ${error.message}`
                : 'Erreur inconnue lors de la diffusion timer'
        );
    }
}

export async function broadcastActiveTool(sessionId: string, tool: string) {
    console.log(`üõ†Ô∏è [ACTION TOOL] - Diffusion de l'outil actif '${tool}' pour la session ${sessionId}`);
    try {
        if (!sessionId || !tool) {
            console.error('‚ùå [ACTION TOOL] - sessionId et tool sont requis.');
            throw new Error('sessionId et tool sont requis');
        }
        const channel = `presence-session-${sessionId}`;
        
        const payload = { 
            tool,
            sessionId,
            timestamp: new Date().toISOString()
        };
        console.log(`  √âv√©nement 'active-tool-changed' diffus√© sur ${channel} avec payload:`, payload);
        await pusherTrigger(
            channel, 
            'active-tool-changed', 
            payload
        );
        
        return { success: true, tool, sessionId };
        
    } catch (error) {
        console.error('üí• [ACTION TOOL] - Erreur:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec de la diffusion de l'outil: ${error.message}`
                : 'Erreur inconnue lors de la diffusion de l\'outil'
        );
    }
}

export async function updateStudentSessionStatus(
  sessionId: string,
  status: { isHandRaised?: boolean; understanding: ComprehensionLevel }
) {
  console.log(`üôã [ACTION STATUS] - Mise √† jour du statut pour un √©l√®ve dans la session ${sessionId}`);
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    console.error('‚ùå [ACTION STATUS] - Utilisateur non authentifi√©.');
    throw new Error('Utilisateur non authentifi√©');
  }
  const userId = session.user.id;
  console.log(`  Utilisateur: ${userId}, Statut √† mettre √† jour:`, status);

  const channel = `presence-session-${sessionId}`;

  if (status.isHandRaised !== undefined) {
    console.log(`  -> Diffusion de 'hand-raise-update' avec isRaised=${status.isHandRaised}`);
    await pusherTrigger(channel, 'hand-raise-update', { userId, isRaised: status.isHandRaised });
  }

     if (status.understanding !== undefined) {
      console.log(`  -> Diffusion de 'understanding-update' avec status=${status.understanding}`);
      await broadcastUnderstandingUpdate(sessionId, userId, status.understanding);
    }

  console.log('‚úÖ [ACTION STATUS] - Mise √† jour du statut diffus√©e avec succ√®s.');
  return { success: true };
}
// Types pour TypeScript
export interface SessionData extends CoursSession {
    invitationResults?: {
        successful: string[];
        failed: string[];
    };
    success?: boolean;
}

export interface SessionDetails {
    id: string;
    participants: any[];
    teacher: User;
    students: User[];
    documentHistory: any[];
}

export async function reinviteStudentToSession(sessionId: string, studentId: string, classroomId: string) {
    console.log(`üîÑ [ACTION REINVITE] - Tentative de r√©-invitation de l'√©l√®ve ${studentId} √† la session ${sessionId}`);
    try {
        const session = await getServerSession(authOptions);
        if (!session?.user || session.user.role !== 'PROFESSEUR') {
            console.error('‚ùå [ACTION REINVITE] - Non autoris√©: Seul un professeur peut r√©-inviter un √©l√®ve.');
            throw new Error("Seul un professeur peut r√©-inviter un √©l√®ve.");
        }
        
        console.log(`  Envoi d'une nouvelle invitation individuelle √† ${studentId}.`);
        await sendIndividualInvitations(sessionId, session.user.id, classroomId, [studentId]);
        
        console.log(`  Revalidation du chemin pour la session: /session/${sessionId}`);
        revalidatePath(`/session/${sessionId}`);
        
        console.log(`‚úÖ [ACTION REINVITE] - Invitation envoy√©e avec succ√®s √† ${studentId}.`);
        return { success: true };
    } catch (error) {
        console.error(`üí• [ACTION REINVITE] - Erreur lors de la r√©-invitation de ${studentId}:`, error);
        throw new Error("Impossible de r√©-inviter l'√©l√®ve.");
    }
}
// AJOUTER CETTE FONCTION DE NETTOYAGE DANS session.actions.ts
 // Nettoie les sessions termin√©es mais non marqu√©es comme telles
 // √Ä appeler p√©riodiquement ou lors de certaines actions
export async function cleanupExpiredSessions() {
    console.log('üßπ [ACTION CLEANUP] - Nettoyage des sessions expir√©es...');
    try {
        // Trouver les sessions sans endTime mais d√©marr√©es il y a plus de 2 heures
        const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
        
        const expiredSessions = await prisma.coursSession.findMany({
            where: {
                endTime: null,
                startTime: {
                    lt: twoHoursAgo
                }
            },
            select: {
                id: true,
                startTime: true
            }
        });

        if (expiredSessions.length > 0) {
            console.log(`üóëÔ∏è [ACTION CLEANUP] - ${expiredSessions.length} sessions expir√©es √† nettoyer`);
            
            for (const session of expiredSessions) {
                console.log(`  -> Marquage comme termin√©e: ${session.id} (d√©marr√©e: ${session.startTime.toISOString()})`);
                await prisma.coursSession.update({
                    where: { id: session.id },
                    data: { endTime: new Date() }
                });
            }
            
            console.log(`‚úÖ [ACTION CLEANUP] - ${expiredSessions.length} sessions nettoy√©es`);
        } else {
            console.log('‚úÖ [ACTION CLEANUP] - Aucune session expir√©e trouv√©e');
        }
        
        return { cleaned: expiredSessions.length };
        
    } catch (error) {
        console.error('‚ùå [ACTION CLEANUP] - Erreur lors du nettoyage:', error);
        throw new Error('√âchec du nettoyage des sessions');
    }
}

// AJOUTER CETTE FONCTION POUR LA COMPR√âHENSION DES √âL√àVES
export async function broadcastUnderstandingUpdate(
    sessionId: string,
    userId: string, 
    understanding: ComprehensionLevel
  ) {
    console.log(`üòä [ACTION UNDERSTANDING] - Diffusion du niveau de compr√©hension pour ${userId}: ${understanding}`);
    
    try {
      if (!sessionId || !userId || !understanding) {
        console.error('‚ùå [ACTION UNDERSTANDING] - Param√®tres manquants.');
        throw new Error('sessionId, userId et understanding sont requis');
      }
  
      const channel = `presence-session-${sessionId}`;
      
      const payload = {
        userId,
        status: understanding, // Correction: le payload attend 'status'
        sessionId,
        timestamp: new Date().toISOString()
      };
  
      console.log(`  -> Diffusion sur ${channel}:`, payload);
      
      await pusherTrigger(channel, 'understanding-update', payload);
      
      console.log('‚úÖ [ACTION UNDERSTANDING] - Niveau de compr√©hension diffus√© avec succ√®s.');
      return { success: true, userId, understanding };
      
    } catch (error) {
      console.error('üí• [ACTION UNDERSTANDING] - Erreur:', error);
      throw new Error('Impossible de diffuser le niveau de compr√©hension');
    }
  }

  export async function shareDocument(
    sessionId: string,
    document: { name: string; url: string }
  ) {
    console.log(`üìÑ [ACTION DOCUMENT] - Partage du document '${document.name}' pour la session ${sessionId}`);
    try {
      const session = await getServerSession(authOptions);
      if (!session?.user) {
        throw new Error("Utilisateur non authentifi√©.");
      }
      
      if (!sessionId || !document?.url || !document?.name) {
        throw new Error('sessionId et document (name, url) sont requis.');
      }
  
      const channel = `presence-session-${sessionId}`;
      const payload = {
        name: document.name,
        url: document.url,
        sharedBy: session.user.name,
        timestamp: new Date().toISOString(),
      };
      
      await pusherTrigger(channel, 'document-shared', payload);
      
      return { success: true };
      
    } catch (error) {
        console.error('üí• [ACTION DOCUMENT] - Erreur d√©taill√©e:', error);
        throw new Error(`Impossible de partager le document: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);
    }
  }
  
