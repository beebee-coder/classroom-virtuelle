// src/lib/actions/session.actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { pusherTrigger } from '../pusher/server';
import { getAuthSession } from '../session';
import { ComprehensionLevel } from '@/components/StudentSessionControls';
import prisma from '../prisma';
import { Role, type CoursSession, type User, type DocumentInHistory } from '@prisma/client';

export async function createCoursSession(professeurId: string, classroomId: string, studentIds: string[]) {
    console.log('üöÄ [ACTION SESSION] - D√©but de la cr√©ation de la session de cours...');
    try {
        console.log(`  Cr√©ation pour prof ${professeurId}, classe ${classroomId} avec ${studentIds.length} √©l√®ve(s).`);
        
        if (!professeurId || !classroomId || !studentIds || !Array.isArray(studentIds)) {
             console.error('‚ùå [ACTION SESSION] - Param√®tres invalides.');
            throw new Error('Param√®tres invalides: professeurId, classroomId et studentIds sont requis');
        }

        const participantIds = [professeurId, ...studentIds];

        // Cr√©er la session et connecter les participants dans une seule transaction
        const session = await prisma.coursSession.create({
            data: {
                professeurId: professeurId,
                classroomId: classroomId,
                participants: {
                    connect: participantIds.map(id => ({ id }))
                }
            },
            include: {
                participants: true
            }
        });

        console.log(`  Session ${session.id} et ses participants cr√©√©s en base de donn√©es.`);

        const invitationResults = await sendIndividualInvitations(session.id, professeurId, classroomId, studentIds);

        // Revalidate the path for each invited student
        studentIds.forEach(id => {
            console.log(`  Revalidation du chemin pour l'√©l√®ve: /student/${id}`);
            revalidatePath(`/student/dashboard`);
            revalidatePath(`/student/${id}`);
        });
        
        console.log('‚úÖ [ACTION SESSION] - Cr√©ation de session termin√©e avec succ√®s.');
        return { 
            id: session.id, 
            professeurId, 
            classroomId,
            invitationResults,
            success: true 
        };
        
    } catch (error) {
        console.error('üí• [ACTION SESSION] - Erreur critique lors de la cr√©ation:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec de la cr√©ation de session: ${error.message}`
                : 'Erreur inconnue lors de la cr√©ation de session'
        );
    }
}

async function sendIndividualInvitations(sessionId: string, professeurId: string, classroomId: string, studentIds: string[]) {
    console.log(`üì® [ACTION INVITATIONS] - D√©but de l'envoi pour la session ${sessionId}`);
    const results = {
        successful: [] as string[],
        failed: [] as string[]
    };

    const classroom = await prisma.classroom.findUnique({ where: { id: classroomId } });
    const teacher = await prisma.user.findUnique({ where: { id: professeurId } });

    const invitationPayload = {
        sessionId: sessionId,
        teacherId: professeurId,
        classroomId: classroomId,
        classroomName: classroom?.nom || 'Classe inconnue',
        teacherName: teacher?.name || 'Professeur',
        timestamp: new Date().toISOString(),
        type: 'session-invitation'
    };
    
    console.log('  Payload d\'invitation pr√©par√©:', invitationPayload);

    // Pas de stockage en m√©moire, Pusher g√®re la livraison en temps r√©el.
    // Pour les invitations manqu√©es, le client pourrait faire un appel pour voir si une session active pour sa classe existe.

    for (const studentId of studentIds) {
        const channelName = `private-user-${studentId}`;
        try {
            console.log(`  -> Envoi √† ${studentId} sur le canal ${channelName}`);
            await pusherTrigger(
                channelName, 
                'session-invitation', 
                invitationPayload
            );
            results.successful.push(studentId);
        } catch (error) {
            console.error(`  -> ‚ùå √âchec de l'envoi pour ${studentId}:`, error);
            results.failed.push(studentId);
        }
    }

    console.log(`üìä [ACTION INVITATIONS] - R√©sum√©: ${results.successful.length} succ√®s, ${results.failed.length} √©checs.`);
    return results;
}


export async function getSessionDetails(sessionId: string) {
    console.log(`‚ÑπÔ∏è [ACTION SESSION DETAILS] - R√©cup√©ration des d√©tails pour la session ${sessionId}`);
    try {
        if (!sessionId) {
            console.error('‚ùå [ACTION SESSION DETAILS] - sessionId est requis.');
            throw new Error('sessionId est requis');
        }

        const session = await prisma.coursSession.findUnique({
            where: { id: sessionId },
            include: {
                professeur: true,
                participants: true,
            }
        });

        if (!session) {
            console.error(`‚ùå [ACTION SESSION DETAILS] - Session non trouv√©e: ${sessionId}`);
            throw new Error('Session non trouv√©e.');
        }

        const students = session.participants
            .filter((p) => p.role === Role.ELEVE);

        console.log('‚úÖ [ACTION SESSION DETAILS] - D√©tails de session r√©cup√©r√©s.');
        return {
            id: session.id,
            teacher: session.professeur,
            students: students,
        };
        
    } catch (error) {
        console.error('üí• [ACTION SESSION DETAILS] - Erreur:', error);
        throw new Error('Impossible de r√©cup√©rer les d√©tails de la session');
    }
}

export async function spotlightParticipant(sessionId: string, participantId: string) {
    console.log(`üåü [ACTION SPOTLIGHT] - Mise en vedette de ${participantId} dans la session ${sessionId}`);
    try {
        if (!sessionId || !participantId) {
            console.error('‚ùå [ACTION SPOTLIGHT] - sessionId et participantId sont requis.');
            throw new Error('sessionId et participantId sont requis');
        }
        const channelName = `presence-session-${sessionId}`;
        
        await pusherTrigger(
            channelName, 
            'participant-spotlighted', 
            { 
                participantId,
                sessionId,
                timestamp: new Date().toISOString()
            }
        );
        console.log(`  √âv√©nement 'participant-spotlighted' diffus√© sur ${channelName}.`);

        revalidatePath(`/session/${sessionId}`);
        console.log('‚úÖ [ACTION SPOTLIGHT] - Action termin√©e avec succ√®s.');
        return { success: true, participantId, sessionId };
        
    } catch (error) {
        console.error('üí• [ACTION SPOTLIGHT] - Erreur:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec du spotlight: ${error.message}`
                : 'Erreur inconnue lors du spotlight'
        );
    }
}

export async function endCoursSession(sessionId: string) {
    console.log(`üîö [ACTION END SESSION] - Tentative de fin de la session ${sessionId}`);
    try {
        if (!sessionId) {
            console.error('‚ùå [ACTION END SESSION] - sessionId est requis.');
            throw new Error('sessionId est requis');
        }

        const session = await prisma.coursSession.update({
            where: { id: sessionId },
            data: { endTime: new Date() }
        });

        const classroomId = session.classroomId;

        const eventData = { 
            sessionId,
            endedAt: new Date().toISOString()
        };
        
        const sessionChannel = `presence-session-${sessionId}`;
        console.log(`  -> Envoi de 'session-ended' au canal de session: ${sessionChannel}`);
        await pusherTrigger(sessionChannel, 'session-ended', eventData);
        
        if (classroomId) {
            const classChannel = `presence-classe-${classroomId}`;
            console.log(`  -> Envoi de 'session-ended' au canal de classe: ${classChannel}`);
            await pusherTrigger(classChannel, 'session-ended', eventData);
        }


        console.log('‚úÖ [ACTION END SESSION] - Session termin√©e avec succ√®s.');
        return { 
            id: sessionId, 
            success: true 
        };
        
    } catch (error) {
        console.error('üí• [ACTION END SESSION] - Erreur:', error);
        throw new Error('Impossible de terminer la session');
    }
}


export async function serverSpotlightParticipant(sessionId: string, participantId: string) {
    console.log(`üåü [ACTION SPOTLIGHT - SERVER] - Ex√©cution de la mise en vedette pour ${participantId}.`);
    return await spotlightParticipant(sessionId, participantId);
}

export async function broadcastTimerEvent(sessionId: string, event: string, data?: any) {
    console.log(`‚è±Ô∏è [ACTION TIMER] - Diffusion de l'√©v√©nement '${event}' pour la session ${sessionId}`);
    try {
        if (!sessionId || !event) {
            console.error('‚ùå [ACTION TIMER] - sessionId et event sont requis.');
            throw new Error('sessionId et event sont requis');
        }
        const channel = `presence-session-${sessionId}`;
        
        const payload = { 
            ...data,
            sessionId,
            timestamp: new Date().toISOString()
        };
        console.log(`  Payload diffus√© sur ${channel}:`, payload);
        await pusherTrigger(
            channel, 
            event, 
            payload
        );
        
        return { success: true, event, sessionId };
        
    } catch (error) {
        console.error('üí• [ACTION TIMER] - Erreur:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec de la diffusion timer: ${error.message}`
                : 'Erreur inconnue lors de la diffusion timer'
        );
    }
}

export async function broadcastActiveTool(sessionId: string, tool: string) {
    console.log(`üõ†Ô∏è [ACTION TOOL] - Diffusion de l'outil actif '${tool}' pour la session ${sessionId}`);
    try {
        if (!sessionId || !tool) {
            console.error('‚ùå [ACTION TOOL] - sessionId et tool sont requis.');
            throw new Error('sessionId et tool sont requis');
        }
        const channel = `presence-session-${sessionId}`;
        
        const payload = { 
            tool,
            sessionId,
            timestamp: new Date().toISOString()
        };
        console.log(`  √âv√©nement 'active-tool-changed' diffus√© sur ${channel} avec payload:`, payload);
        await pusherTrigger(
            channel, 
            'active-tool-changed', 
            payload
        );
        
        return { success: true, tool, sessionId };
        
    } catch (error) {
        console.error('üí• [ACTION TOOL] - Erreur:', error);
        throw new Error(
            error instanceof Error 
                ? `√âchec de la diffusion de l'outil: ${error.message}`
                : 'Erreur inconnue lors de la diffusion de l\'outil'
        );
    }
}

export async function updateStudentSessionStatus(
  sessionId: string,
  status: { isHandRaised?: boolean; understanding?: ComprehensionLevel }
) {
  console.log(`üôã [ACTION STATUS] - Mise √† jour du statut pour un √©l√®ve dans la session ${sessionId}`);
  const session = await getAuthSession();
  if (!session?.user?.id) {
    console.error('‚ùå [ACTION STATUS] - Utilisateur non authentifi√©.');
    throw new Error('Utilisateur non authentifi√©');
  }
  const userId = session.user.id;
  console.log(`  Utilisateur: ${userId}, Statut √† mettre √† jour:`, status);

  const channel = `presence-session-${sessionId}`;

  if (status.isHandRaised !== undefined) {
    console.log(`  -> Diffusion de 'hand-raise-update' avec isRaised=${status.isHandRaised}`);
    await pusherTrigger(channel, 'hand-raise-update', { userId, isRaised: status.isHandRaised });
  }

  //   if (status.understanding !== undefined) {
  //     console.log(`  -> Diffusion de 'understanding-update' avec status=${status.understanding}`);
  //     await pusherTrigger(channel, 'understanding-update', { userId, status: status.understanding });
  //   }

  console.log('‚úÖ [ACTION STATUS] - Mise √† jour du statut diffus√©e avec succ√®s.');
  return { success: true };
}

// Types pour TypeScript
export interface SessionData extends CoursSession {
    invitationResults?: {
        successful: string[];
        failed: string[];
    };
    success?: boolean;
}

export interface SessionDetails {
    id: string;
    participants: any[];
    teacher: User;
    students: User[];
}

export async function reinviteStudentToSession(sessionId: string, studentId: string, classroomId: string) {
    console.log(`üîÑ [ACTION REINVITE] - Tentative de r√©-invitation de l'√©l√®ve ${studentId} √† la session ${sessionId}`);
    try {
        const session = await getAuthSession();
        if (!session?.user || session.user.role !== 'PROFESSEUR') {
            console.error('‚ùå [ACTION REINVITE] - Non autoris√©: Seul un professeur peut r√©-inviter un √©l√®ve.');
            throw new Error("Seul un professeur peut r√©-inviter un √©l√®ve.");
        }
        
        console.log(`  Envoi d'une nouvelle invitation individuelle √† ${studentId}.`);
        await sendIndividualInvitations(sessionId, session.user.id, classroomId, [studentId]);
        
        console.log(`  Revalidation du chemin pour la session: /session/${sessionId}`);
        revalidatePath(`/session/${sessionId}`);
        
        console.log(`‚úÖ [ACTION REINVITE] - Invitation envoy√©e avec succ√®s √† ${studentId}.`);
        return { success: true };
    } catch (error) {
        console.error(`üí• [ACTION REINVITE] - Erreur lors de la r√©-invitation de ${studentId}:`, error);
        throw new Error("Impossible de r√©-inviter l'√©l√®ve.");
    }
}

export async function shareDocument(sessionId: string, document: DocumentInHistory) {
    console.log(`üìÑ [ACTION DOCUMENT] - Partage du document '${document.name}' pour la session ${sessionId}`);
    try {
        if (!sessionId || !document?.url || !document?.name) {
            throw new Error('sessionId et document (name, url) sont requis.');
        }

        const session = await prisma.coursSession.findUnique({
            where: { id: sessionId },
            select: { documentHistory: true }
        });

        if (!session) {
            throw new Error('Session non trouv√©e.');
        }

        const currentHistory = (session.documentHistory as DocumentInHistory[] | null) || [];
        
        const isAlreadyInHistory = currentHistory.some(doc => doc.url === document.url);
        
        let updatedHistory = currentHistory;
        if (!isAlreadyInHistory) {
            updatedHistory = [...currentHistory, document];
            await prisma.coursSession.update({
                where: { id: sessionId },
                data: { documentHistory: updatedHistory as any }
            });
            console.log(`  Historique des documents mis √† jour en base de donn√©es.`);
        } else {
             console.log(`  Document d√©j√† pr√©sent dans l'historique.`);
        }

        const channel = `presence-session-${sessionId}`;
        const payload = {
            url: document.url,
            newHistory: updatedHistory,
        };
        
        console.log(`  Diffusion de l'√©v√©nement 'document-updated' sur le canal ${channel}.`);
        await pusherTrigger(channel, 'document-updated', payload);
        
        return { success: true };
    } catch (error) {
        console.error('üí• [ACTION DOCUMENT] - Erreur:', error);
        throw new Error("Impossible de partager le document.");
    }
}
