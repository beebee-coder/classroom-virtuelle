// src/lib/actions/teacher.actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import prisma from '../prisma';
import type { StudentProgress, Task, User } from '@prisma/client';
import { ProgressStatus } from '@prisma/client';


export type TaskForProfessorValidation = StudentProgress & {
  task: Task;
  student: Pick<User, 'id' | 'name'>;
};


export async function getTasksForProfessorValidation(teacherId: string): Promise<TaskForProfessorValidation[]> {
    console.log(`üßë‚Äçüè´ [ACTION] getTasksForProfessorValidation pour le professeur: ${teacherId}.`);
    
    // 1. Trouver les classes du professeur
    const classrooms = await prisma.classroom.findMany({
        where: { professeurId: teacherId },
        select: { id: true }
    });
    const classroomIds = classrooms.map(c => c.id);
    console.log(`  -> Professeur g√®re ${classroomIds.length} classe(s).`);

    // 2. Trouver les √©l√®ves dans ces classes
    const students = await prisma.user.findMany({
        where: { classeId: { in: classroomIds } },
        select: { id: true }
    });
    const studentIds = students.map(s => s.id);

    // 3. Trouver les soumissions en attente de ces √©l√®ves pour les t√¢ches n√©cessitant une validation par le professeur
    const tasks = await prisma.studentProgress.findMany({
        where: {
            studentId: { in: studentIds },
            status: ProgressStatus.PENDING_VALIDATION,
            task: {
                validationType: 'PROFESSOR'
            }
        },
        include: {
            task: true,
            student: {
                select: { id: true, name: true }
            }
        },
        orderBy: {
            completionDate: 'asc'
        }
    });
    console.log(`  -> ${tasks.length} t√¢che(s) trouv√©e(s) pour validation.`);
    return tasks;
}

export interface ProfessorValidationPayload {
    progressId: string;
    approved: boolean;
    pointsAwarded?: number;
    rejectionReason?: string;
}

export async function validateTaskByProfessor(payload: ProfessorValidationPayload) {
    console.log('üëç [ACTION] validateTaskByProfessor:', payload);
    const { progressId, approved, pointsAwarded } = payload;
    
    const progress = await prisma.studentProgress.findUnique({
        where: { id: progressId },
        include: { task: true, student: true }
    });

    if (!progress) {
        console.error(`‚ùå [ACTION] Progression non trouv√©e: ${progressId}`);
        throw new Error("Progression de t√¢che non trouv√©e.");
    }
    
    if (approved) {
        const finalPoints = pointsAwarded ?? progress.task.points;
        console.log(`  -> Approbation. Attribution de ${finalPoints} points √† ${progress.student.name}.`);
        
        await prisma.$transaction([
            prisma.studentProgress.update({
                where: { id: progressId },
                data: {
                    status: ProgressStatus.VERIFIED,
                    pointsAwarded: finalPoints
                }
            }),
            prisma.user.update({
                where: { id: progress.studentId },
                data: { points: { increment: finalPoints } }
            })
        ]);
    } else {
        console.log(`  -> Rejet de la t√¢che.`);
        await prisma.studentProgress.update({
            where: { id: progressId },
            data: { 
                status: ProgressStatus.REJECTED,
                // TODO: Ajouter un champ pour le motif de rejet
            }
        });
    }

    revalidatePath('/teacher/validations');
    revalidatePath(`/student/dashboard`); // Pour que l'√©l√®ve voie la mise √† jour
    revalidatePath(`/student/${progress.studentId}`);
    
    console.log(`‚úÖ [ACTION] Validation termin√©e pour ${progressId}.`);
    return {
        studentName: progress.student.name,
        taskTitle: progress.task.title,
        pointsAwarded: approved ? (pointsAwarded ?? progress.task.points) : 0,
    };
}

export async function resetAllStudentData() {
  console.log('üîÑ [ACTION] resetAllStudentData - Lancement de la r√©initialisation compl√®te.');
  
  await prisma.$transaction([
    // 1. Remettre tous les points des √©l√®ves √† 0
    prisma.user.updateMany({
        where: { role: 'ELEVE' },
        data: { points: 0 }
    }),
    // 2. Supprimer toute la progression des √©l√®ves
    prisma.studentProgress.deleteMany({}),
  ]);

  console.log("‚úÖ [ACTION] Toutes les donn√©es des √©l√®ves ont √©t√© r√©initialis√©es.");

  revalidatePath('/teacher', 'layout'); // Revalider toutes les pages enseignantes
  revalidatePath('/student', 'layout'); // Revalider toutes les pages √©l√®ves
  
  return { success: true, message: "Toutes les donn√©es des √©l√®ves ont √©t√© r√©initialis√©es avec succ√®s." };
}
