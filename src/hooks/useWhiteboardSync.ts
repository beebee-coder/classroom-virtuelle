// src/hooks/useWhiteboardSync.ts
'use client';

import { useState, useCallback, useEffect, useRef } from 'react';
import { ExcalidrawScene } from '@/types';
import { getPusherClient } from '@/lib/pusher/client';

const WHITEBOARD_UPDATE_EVENT = 'whiteboard-update';
const DEBOUNCE_SAVE_TIME = 1000; // ‚ö†Ô∏è CORRECTION : Augmenter √† 1s pour plus de stabilit√©

export const useWhiteboardSync = (
    sessionId: string,
    initialScene: ExcalidrawScene | null
) => {
    const [sceneData, setSceneData] = useState<ExcalidrawScene | null>(initialScene);
    const [isLoading, setIsLoading] = useState(!initialScene);
    
    // ‚ö†Ô∏è CORRECTION CRITIQUE : R√©f√©rences pour contr√¥ler les boucles
    const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const lastSceneJSON = useRef<string | null>(initialScene ? JSON.stringify(initialScene) : null);
    const hasFetchedInitial = useRef(false);
    const isUpdatingFromExternal = useRef(false);
    const isPersisting = useRef(false); // ‚ö†Ô∏è CORRECTION : Nouveau flag pour √©viter les r√©cursions
    const pusherChannelRef = useRef<any>(null);

    // ‚ö†Ô∏è CORRECTION : Effet pour le chargement initial - UNIQUEMENT si n√©cessaire
    useEffect(() => {
        if (hasFetchedInitial.current || initialScene) return;

        const fetchInitialScene = async () => {
            console.log('üé® [TB SYNC] Chargement de la sc√®ne initiale...');
            setIsLoading(true);
            
            try {
                const response = await fetch(`/api/session/${sessionId}/sync`);
                if (response.ok) {
                    const data: ExcalidrawScene | null = await response.json();
                    if (data) {
                        const sceneJSON = JSON.stringify(data);
                        if (sceneJSON !== lastSceneJSON.current) {
                            console.log('üé® [TB SYNC] Sc√®ne initiale charg√©e');
                            isUpdatingFromExternal.current = true; // ‚ö†Ô∏è CORRECTION : Marquer comme externe
                            setSceneData(data);
                            lastSceneJSON.current = sceneJSON;
                        }
                    }
                }
            } catch (error) {
                console.error("‚ùå [TB SYNC] Erreur lors du chargement initial:", error);
            } finally {
                setIsLoading(false);
                hasFetchedInitial.current = true;
            }
        };

        fetchInitialScene();
    }, [sessionId, initialScene]);

    // ‚ö†Ô∏è CORRECTION CRITIQUE : Effet Pusher avec gestion robuste des canaux
    useEffect(() => {
        console.log('üîå [TB SYNC] Initialisation de l\'abonnement Pusher');
        const pusherClient = getPusherClient();
        const channelName = `presence-session-${sessionId}`;
        
        // ‚ö†Ô∏è CORRECTION : V√©rifier si on est d√©j√† abonn√© √† ce canal
        if (pusherChannelRef.current && pusherChannelRef.current.name === channelName) {
            console.log('üîå [TB SYNC] D√©j√† abonn√© √† ce canal, skip');
            return;
        }

        // ‚ö†Ô∏è CORRECTION : Se d√©sabonner de l'ancien canal si existe
        if (pusherChannelRef.current) {
            pusherClient.unsubscribe(pusherChannelRef.current.name);
        }

        const channel = pusherClient.subscribe(channelName);
        pusherChannelRef.current = channel;

        const handleUpdate = (data: { sceneData: ExcalidrawScene, senderId: string }) => {
            // ‚ö†Ô∏è CORRECTION : Ignorer si on est en train de persister
            if (isPersisting.current) {
                console.log('‚û°Ô∏è [TB SYNC] Mise √† jour ignor√©e (en cours de persistance)');
                return;
            }

            // ‚ö†Ô∏è CORRECTION : V√©rifications renforc√©es pour √©viter les boucles
            if (data.senderId === pusherClient.connection.socket_id) {
                console.log('‚û°Ô∏è [TB SYNC] Mise √† jour ignor√©e (propre √©mission)');
                return;
            };
            
            const newSceneJSON = JSON.stringify(data.sceneData);
            if (newSceneJSON !== lastSceneJSON.current) {
                console.log('üé® [TB SYNC] Mise √† jour Pusher re√ßue');
                isUpdatingFromExternal.current = true; // Marquer comme externe
                setSceneData(data.sceneData);
                lastSceneJSON.current = newSceneJSON;
                
                // ‚ö†Ô∏è CORRECTION : R√©initialiser le flag apr√®s un court d√©lai
                setTimeout(() => {
                    isUpdatingFromExternal.current = false;
                }, 100);
            }
        };

        channel.bind(WHITEBOARD_UPDATE_EVENT, handleUpdate);

        return () => {
            console.log('üîå [TB SYNC] Nettoyage: D√©sabonnement Pusher');
            if (channel) {
                channel.unbind(WHITEBOARD_UPDATE_EVENT, handleUpdate);
                pusherClient.unsubscribe(channelName);
            }
            
            if (saveTimeoutRef.current) {
                clearTimeout(saveTimeoutRef.current);
                saveTimeoutRef.current = null;
            }
            
            pusherChannelRef.current = null;
        };
    }, [sessionId]);

    // ‚ö†Ô∏è CORRECTION CRITIQUE : persistScene avec protection compl√®te contre les boucles
    const persistScene = useCallback((data: ExcalidrawScene) => {
        // ‚ö†Ô∏è CORRECTION : Ignorer si la mise √† jour vient d'une source externe
        if (isUpdatingFromExternal.current) {
            console.log('üö´ [TB SYNC] Mise √† jour ignor√©e (source externe)');
            return;
        }

        // ‚ö†Ô∏è CORRECTION : Ignorer si d√©j√† en train de persister
        if (isPersisting.current) {
            console.log('üö´ [TB SYNC] Mise √† jour ignor√©e (d√©j√† en persistance)');
            return;
        }

        console.log('üíæ [TB SYNC] persistScene appel√©e');
        const pusherClient = getPusherClient();
        const newSceneJSON = JSON.stringify(data);

        // ‚ö†Ô∏è CORRECTION : V√©rification plus stricte des changements
        if (newSceneJSON === lastSceneJSON.current) {
            console.log('ü§∑‚Äç‚ôÇÔ∏è [TB SYNC] Aucun changement d√©tect√©, skip');
            return;
        }

        console.log('üé® [TB SYNC] Changement local d√©tect√© - mise √† jour optimiste');
        
        // ‚ö†Ô∏è CORRECTION : Marquer comme persistant pour √©viter les r√©cursions
        isPersisting.current = true;
        setSceneData(data);
        lastSceneJSON.current = newSceneJSON;

        // ‚ö†Ô∏è CORRECTION : Nettoyer le timeout pr√©c√©dent
        if (saveTimeoutRef.current) {
            clearTimeout(saveTimeoutRef.current);
        }

        // ‚ö†Ô∏è CORRECTION : D√©bouncer l'envoi avec timeout plus long
        saveTimeoutRef.current = setTimeout(async () => {
            try {
                console.log('üì° [TB SYNC] Envoi des donn√©es √† l\'API');
                
                const response = await fetch(`/api/session/${sessionId}/sync`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sceneData: data,
                        senderSocketId: pusherClient.connection.socket_id,
                    }),
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                console.log('‚úÖ [TB SYNC] Donn√©es synchronis√©es avec succ√®s');
                
            } catch (error) {
                console.error("‚ùå [TB SYNC] Erreur de synchronisation:", error);
            } finally {
                // ‚ö†Ô∏è CORRECTION : R√©initialiser les flags apr√®s l'envoi
                isPersisting.current = false;
                saveTimeoutRef.current = null;
            }
        }, DEBOUNCE_SAVE_TIME);

    }, [sessionId]);

    // ‚ö†Ô∏è CORRECTION : Effet pour r√©initialiser le flag de persistance en cas d'erreur
    useEffect(() => {
        return () => {
            if (saveTimeoutRef.current) {
                clearTimeout(saveTimeoutRef.current);
                isPersisting.current = false;
            }
        };
    }, []);

    console.log('üîÑ [TB SYNC] Rendu du hook - isLoading:', isLoading);
    
    return {
        sceneData,
        persistScene,
        isLoading,
    };
};