// src/hooks/useWhiteboardSync.ts
'use client';

import { useState, useCallback, useEffect, useRef } from 'react';
import { ExcalidrawScene } from '@/types';
import { getPusherClient } from '@/lib/pusher/client';

const WHITEBOARD_UPDATE_EVENT = 'whiteboard-update';
const DEBOUNCE_SAVE_TIME = 500; // ‚ö†Ô∏è CORRECTION : Augmenter le debounce

export const useWhiteboardSync = (
    sessionId: string,
    initialScene: ExcalidrawScene | null
) => {
    const [sceneData, setSceneData] = useState<ExcalidrawScene | null>(initialScene);
    const [isLoading, setIsLoading] = useState(!initialScene);
    const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const lastSceneJSON = useRef<string | null>(initialScene ? JSON.stringify(initialScene) : null);
    const hasFetchedInitial = useRef(false);
    const isUpdatingFromExternal = useRef(false); // ‚ö†Ô∏è CORRECTION : Nouvelle r√©f√©rence

    // ‚ö†Ô∏è CORRECTION : Effet simplifi√© pour le chargement initial
    useEffect(() => {
        if (hasFetchedInitial.current || initialScene) return;

        const fetchInitialScene = async () => {
            console.log('üé® [TB SYNC] Chargement de la sc√®ne initiale...');
            setIsLoading(true);
            
            try {
                const response = await fetch(`/api/session/${sessionId}/sync`);
                if (response.ok) {
                    const data: ExcalidrawScene | null = await response.json();
                    if (data) {
                        const sceneJSON = JSON.stringify(data);
                        if (sceneJSON !== lastSceneJSON.current) {
                            console.log('üé® [TB SYNC] Sc√®ne initiale charg√©e');
                            isUpdatingFromExternal.current = true; // ‚ö†Ô∏è CORRECTION : Marquer comme mise √† jour externe
                            setSceneData(data);
                            lastSceneJSON.current = sceneJSON;
                        }
                    }
                }
            } catch (error) {
                console.error("‚ùå [TB SYNC] Erreur lors du chargement initial:", error);
            } finally {
                setIsLoading(false);
                hasFetchedInitial.current = true;
            }
        };

        fetchInitialScene();
    }, [sessionId, initialScene]);

    // ‚ö†Ô∏è CORRECTION : Effet Pusher avec protection contre les boucles
    useEffect(() => {
        console.log('üîå [TB SYNC] Initialisation de l\'abonnement Pusher');
        const pusherClient = getPusherClient();
        const channelName = `presence-session-${sessionId}`;
        
        if (pusherClient.channel(channelName)) {
            console.log('üîå [TB SYNC] D√©j√† abonn√©, skip');
            return;
        }

        const channel = pusherClient.subscribe(channelName);

        const handleUpdate = (data: { sceneData: ExcalidrawScene, senderId: string }) => {
            // ‚ö†Ô∏è CORRECTION : V√©rifications renforc√©es
            if (data.senderId === pusherClient.connection.socket_id) {
                console.log('‚û°Ô∏è [TB SYNC] Mise √† jour ignor√©e (propre √©mission)');
                return;
            };
            
            const newSceneJSON = JSON.stringify(data.sceneData);
            if (newSceneJSON !== lastSceneJSON.current) {
                console.log('üé® [TB SYNC] Mise √† jour Pusher re√ßue');
                isUpdatingFromExternal.current = true; // ‚ö†Ô∏è CORRECTION : Marquer comme externe
                setSceneData(data.sceneData);
                lastSceneJSON.current = newSceneJSON;
            }
        };

        channel.bind(WHITEBOARD_UPDATE_EVENT, handleUpdate);

        return () => {
            console.log('üîå [TB SYNC] Nettoyage: D√©sabonnement Pusher');
            channel.unbind(WHITEBOARD_UPDATE_EVENT, handleUpdate);
            pusherClient.unsubscribe(channelName);
            
            if (saveTimeoutRef.current) {
                clearTimeout(saveTimeoutRef.current);
                saveTimeoutRef.current = null;
            }
        };
    }, [sessionId]);

    // ‚ö†Ô∏è CORRECTION : persistScene avec protection contre les boucles
    const persistScene = useCallback((data: ExcalidrawScene) => {
        // ‚ö†Ô∏è CORRECTION : Ignorer si la mise √† jour vient d'une source externe
        if (isUpdatingFromExternal.current) {
            console.log('üö´ [TB SYNC] Mise √† jour ignor√©e (source externe)');
            isUpdatingFromExternal.current = false;
            return;
        }

        console.log('üíæ [TB SYNC] persistScene appel√©e');
        const pusherClient = getPusherClient();
        const newSceneJSON = JSON.stringify(data);

        // ‚ö†Ô∏è CORRECTION : V√©rification plus stricte des changements
        if (newSceneJSON === lastSceneJSON.current) {
            console.log('ü§∑‚Äç‚ôÇÔ∏è [TB SYNC] Aucun changement d√©tect√©, skip');
            return;
        }

        console.log('üé® [TB SYNC] Changement local d√©tect√© - mise √† jour optimiste');
        setSceneData(data);
        lastSceneJSON.current = newSceneJSON;

        // ‚ö†Ô∏è CORRECTION : Nettoyer le timeout pr√©c√©dent
        if (saveTimeoutRef.current) {
            clearTimeout(saveTimeoutRef.current);
        }

        // ‚ö†Ô∏è CORRECTION : D√©bouncer l'envoi avec timeout plus long
        saveTimeoutRef.current = setTimeout(() => {
            console.log('üì° [TB SYNC] Envoi des donn√©es √† l\'API');
            fetch(`/api/session/${sessionId}/sync`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sceneData: data,
                    senderSocketId: pusherClient.connection.socket_id,
                }),
            }).catch(error => {
                console.error("‚ùå [TB SYNC] Erreur de synchronisation:", error);
            });
            
            saveTimeoutRef.current = null;
        }, DEBOUNCE_SAVE_TIME);

    }, [sessionId]);

    console.log('üîÑ [TB SYNC] Rendu du hook - isLoading:', isLoading);
    
    return {
        sceneData,
        persistScene,
        isLoading,
    };
};