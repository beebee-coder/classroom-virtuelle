
// src/hooks/useWhiteboardSync.ts
'use client';

import { useState, useCallback, useEffect, useRef } from 'react';
import { ExcalidrawScene } from '@/types';
import { getPusherClient } from '@/lib/pusher/client';

const WHITEBOARD_UPDATE_EVENT = 'whiteboard-update';
const DEBOUNCE_SAVE_TIME = 200;

export const useWhiteboardSync = (
    sessionId: string,
    initialScene: ExcalidrawScene | null
) => {
    const [sceneData, setSceneData] = useState<ExcalidrawScene | null>(initialScene);
    const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const lastSceneJSON = useRef<string | null>(JSON.stringify(initialScene));

    // Fonction pour r√©cup√©rer le snapshot initial
    useEffect(() => {
        const fetchInitialScene = async () => {
            console.log('üé® [TB SYNC] 1. useEffect: Tentative de chargement de la sc√®ne initiale depuis l\'API...');
            try {
                const response = await fetch(`/api/session/${sessionId}/sync`);
                if (response.ok) {
                    const data: ExcalidrawScene | null = await response.json();
                    if (data) {
                        const sceneJSON = JSON.stringify(data);
                        if (sceneJSON !== lastSceneJSON.current) {
                            console.log('üé® [TB SYNC] 2. ‚úÖ Sc√®ne initiale charg√©e et diff√©rente. Mise √† jour de l\'√©tat.');
                            setSceneData(data);
                            lastSceneJSON.current = sceneJSON;
                        } else {
                            console.log('üé® [TB SYNC] 2. ü§∑‚Äç‚ôÇÔ∏è Sc√®ne initiale charg√©e mais identique. Aucune mise √† jour.');
                        }
                    } else {
                         console.log('üé® [TB SYNC] 2. ÌÖÖ Sc√®ne initiale vide re√ßue de l\'API.');
                    }
                }
            } catch (error) {
                console.error("‚ùå [TB SYNC] Erreur lors de la r√©cup√©ration de la sc√®ne initiale:", error);
            }
        };

        if (!initialScene) {
             fetchInitialScene();
        } else {
            console.log('üé® [TB SYNC] 1. useEffect: Sc√®ne initiale d√©j√† fournie, pas de fetch.');
        }
    }, [sessionId]);

    // Effet pour l'abonnement Pusher
    useEffect(() => {
        console.log('üîå [TB SYNC] 3. useEffect: Initialisation de l\'abonnement Pusher.');
        const pusherClient = getPusherClient();
        const channelName = `presence-session-${sessionId}`;
        const channel = pusherClient.subscribe(channelName);

        const handleUpdate = (data: { sceneData: ExcalidrawScene, senderId: string }) => {
            if (data.senderId === pusherClient.connection.socket_id) {
                console.log('‚û°Ô∏è [TB SYNC] 4a. Mise √† jour Pusher ignor√©e (propre √©mission).');
                return;
            };
            
            const newSceneJSON = JSON.stringify(data.sceneData);
            if (newSceneJSON !== lastSceneJSON.current) {
                console.log('üé® [TB SYNC] 4b. ‚úÖ Mise √† jour Pusher re√ßue et diff√©rente. Mise √† jour de l\'√©tat.');
                setSceneData(data.sceneData);
                lastSceneJSON.current = newSceneJSON;
            } else {
                console.log('üé® [TB SYNC] 4b. ü§∑‚Äç‚ôÇÔ∏è Mise √† jour Pusher re√ßue mais identique. Aucune mise √† jour.');
            }
        };
        
        channel.bind(WHITEBOARD_UPDATE_EVENT, handleUpdate);

        return () => {
            console.log('üîå [TB SYNC] 8. Nettoyage: D√©sabonnement du canal Pusher.');
            channel.unbind(WHITEBOARD_UPDATE_EVENT, handleUpdate);
            pusherClient.unsubscribe(channelName);
             if (saveTimeoutRef.current) {
                clearTimeout(saveTimeoutRef.current);
            }
        };
    }, [sessionId]);

    const persistScene = useCallback((data: ExcalidrawScene) => {
        console.log('üíæ [TB SYNC] 5. persistScene: Appel√©e par un changement sur le tableau blanc.');
        const pusherClient = getPusherClient();
        const newSceneJSON = JSON.stringify(data);

        // Mise √† jour optimiste uniquement si les donn√©es changent
        if (newSceneJSON !== lastSceneJSON.current) {
            console.log('üé® [TB SYNC] 5a. ‚úÖ Changement local d√©tect√©. Mise √† jour de l\'√©tat optimiste.');
            setSceneData(data);
            lastSceneJSON.current = newSceneJSON;
        } else {
            console.log('üé® [TB SYNC] 5a. ü§∑‚Äç‚ôÇÔ∏è Changement local non significatif. Pas de mise √† jour d\'√©tat.');
        }

        if (saveTimeoutRef.current) {
            clearTimeout(saveTimeoutRef.current);
        }

        saveTimeoutRef.current = setTimeout(() => {
            console.log('üì° [TB SYNC] 6. setTimeout: Envoi des donn√©es persist√©es √† l\'API apr√®s debounce.');
            fetch(`/api/session/${sessionId}/sync`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sceneData: data,
                    senderSocketId: pusherClient.connection.socket_id,
                }),
            }).catch(error => {
                console.error("‚ùå [TB SYNC] Erreur lors de la synchronisation du tableau blanc:", error);
            });
        }, DEBOUNCE_SAVE_TIME);

    }, [sessionId]);
    
    console.log('üîÑ [TB SYNC] 7. Rendu du hook useWhiteboardSync.');
    return {
        sceneData,
        persistScene,
    };
};
