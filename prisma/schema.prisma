// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

model User {
  id                  String           @id @default(cuid())
  name                String?
  email               String?          @unique
  emailVerified       DateTime?
  image               String?
  role                Role             @default(ELEVE)
  points              Int              @default(0)
  ambition            String?
  parentPassword      String?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  classeId            String?
  classe              Classroom?       @relation("StudentsInClass", fields: [classeId], references: [id])
  classesEnseignees   Classroom[]      @relation("TeacherToClass")
  sessionsEnseignees  CoursSession[]   @relation("SessionTeacher")
  sessionsParticipees CoursSession[]   @relation("SessionParticipants")
  announcements       Announcement[]
  leaderboard         Leaderboard?
  messages            Message[]
  reactions           Reaction[]
  conversations       Conversation[]   @relation("Participants")
  initiatedConvs      Conversation[]   @relation("Initiator")
  receivedConvs       Conversation[]   @relation("Receiver")
  EtatEleve           EtatEleve?
  progress            StudentProgress[] // Correction: Ajout de la relation inverse
}

model Classroom {
  id              String         @id @default(cuid())
  nom             String
  professeurId    String
  professeur      User           @relation("TeacherToClass", fields: [professeurId], references: [id])
  eleves          User[]         @relation("StudentsInClass")
  announcements   Announcement[]
  sessions        CoursSession[]
  messages        Message[]
}

model CoursSession {
  id             String   @id @default(cuid())
  professeur     User     @relation("SessionTeacher", fields: [professeurId], references: [id])
  professeurId   String
  participants   User[]   @relation("SessionParticipants")
  classe         Classroom @relation(fields: [classeId], references: [id])
  classeId       String
  demarrage      DateTime @default(now())
  fin            DateTime?
  duree          Int? // en minutes
  enregistrement String? // URL de l'enregistrement
  chatLog        Json?
}

model Metier {
  id          String    @id @default(cuid())
  nom         String    @unique
  description String
  icon        String
  theme       Json // Store theme properties as JSON
  etatsEleves EtatEleve[]
}

model EtatEleve {
  id         String  @id @default(cuid())
  eleve      User    @relation(fields: [eleveId], references: [id])
  eleveId    String  @unique
  isPunished Boolean @default(false)
  metier     Metier? @relation(fields: [metierId], references: [id])
  metierId   String?
}

model Leaderboard {
  id             String   @id @default(cuid())
  studentId      String   @unique
  student        User     @relation(fields: [studentId], references: [id])
  dailyPoints    Int      @default(0)
  weeklyPoints   Int      @default(0)
  monthlyPoints  Int      @default(0)
  totalPoints    Int      @default(0)
  completedTasks Int      @default(0)
  currentStreak  Int      @default(0)
  bestStreak     Int      @default(0)
  rank           Int      @default(0)
  lastUpdated    DateTime @updatedAt
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

enum Role {
  ELEVE
  PROFESSEUR
}

enum TaskType {
  DAILY
  WEEKLY
  MONTHLY
}

enum TaskCategory {
  MATH
  LANGUAGE
  SCIENCE
  HISTORY
  ART
  SPORT
  HOME
  SOCIAL
}

enum TaskDifficulty {
  EASY
  MEDIUM
  HARD
}

enum ValidationType {
  AUTOMATIC
  PARENT
  PROFESSOR
}

enum ProgressStatus {
  PENDING_ASSIGNMENT
  IN_PROGRESS
  PENDING_VALIDATION
  VERIFIED
  REJECTED
}

model Task {
  id             String          @id @default(cuid())
  title          String
  description    String
  points         Int
  type           TaskType
  category       TaskCategory
  difficulty     TaskDifficulty
  validationType ValidationType
  requiresProof  Boolean         @default(false)
  attachmentUrl  String?
  isActive       Boolean         @default(true)
  startTime      DateTime?
  duration       Int? // en minutes
  progress       StudentProgress[]
}

model StudentProgress {
  id             String         @id @default(cuid())
  studentId      String
  student        User           @relation(fields: [studentId], references: [id])
  taskId         String
  task           Task           @relation(fields: [taskId], references: [id])
  status         ProgressStatus @default(PENDING_VALIDATION)
  completionDate DateTime?
  submissionUrl  String?
  pointsAwarded  Int?
  feedback       Json?
  accuracy       Float?
  recipeName     String?
}

model Message {
  id                   String        @id @default(cuid())
  message              String
  createdAt            DateTime      @default(now())
  senderId             String
  sender               User          @relation(fields: [senderId], references: [id])
  classroomId          String?
  classroom            Classroom?    @relation(fields: [classroomId], references: [id])
  isQuestion           Boolean       @default(false)
  conversationId       String?
  conversation         Conversation? @relation(fields: [conversationId], references: [id])
  directMessageSenderId String?
  reactions            Reaction[]
}

model Reaction {
  id        String  @id @default(cuid())
  emoji     String
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  message   Message @relation(fields: [messageId], references: [id])
  messageId String
}

model Announcement {
  id            String     @id @default(cuid())
  title         String
  content       String
  createdAt     DateTime   @default(now())
  author        User       @relation(fields: [authorId], references: [id])
  authorId      String
  classe        Classroom? @relation(fields: [classeId], references: [id])
  classeId      String?
  attachmentUrl String?
}

model Conversation {
  id          String    @id @default(cuid())
  initiator   User      @relation("Initiator", fields: [initiatorId], references: [id])
  initiatorId String
  receiver    User      @relation("Receiver", fields: [receiverId], references: [id])
  receiverId  String
  messages    Message[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  participants User[]   @relation("Participants")
}
